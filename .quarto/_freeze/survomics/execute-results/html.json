{
  "hash": "6e089e153de6df79cd23e9f3964c4f1c",
  "result": {
    "markdown": "---\ntitle: \"Supplemental information for 'Tutorial on survival modeling with applications to omics data'\"\ndate: \"last-modified\"\ntoc: true\ntoc-title: \"**Table of Contents**\"\ntoc-depth: 4\nappendix-style: none\nbibliography: \"references.bib\"\nfig-align: left\n---\n\n\n\n<br>\nThis is a step-by-step R tutorial using [The Cancer Genome Atlas](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga) (TCGA) survival and omics data for the article [**_Tutorial on survival modeling with applications to omics data_**](https://doi.org/10.1093/bioinformatics/btae132) [@Zhao2024].\n\n## Introduction {-}\n\nThe TCGA database provides an enormous collection of cancer data sets, including survival, clinical and multi-omics data.\n\n:::{.callout-tip}\n## We will use TCGA data to demonstrate:\n\n- The different data types\n- Preprocessing of survival and omics data\n- Analysis of survival data by classical statistical methods\n- Unsupervised learning for omics data\n- Frequentist & Bayesian supervised learning for survival and omics data\n:::\n\n## TCGA survival and clinical data {-}\n\nThe R/Bioconductor package [**TCGAbiolinks**](https://bioconductor.org/packages/TCGAbiolinks/) [@Mounir2019] provides a few functions to download and preprocess clinical and multi-omics data from the [Genomic Data Commons](https://gdc.cancer.gov/) (GDC) Data Portal for further analysis.\n\nFirst we load all necessary libraries used in this tutorial except [**mlr3** libraries](#mlr3) which will be introduced later. \nThen we use function `GDCquery_clinic()` from **TCGAbiolinks** package to query and download TCGA survival and clinical data from multiple cancer types:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load all libraries used in this tutorial except mlr3\nlibrary(\"TCGAbiolinks\")\nlibrary(\"SummarizedExperiment\")\nlibrary(\"DESeq2\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"survival\")\nlibrary(\"survminer\")\nlibrary(\"M3C\")\nlibrary(\"glmnet\")\nlibrary(\"plotmo\")\nlibrary(\"grpreg\")\nlibrary(\"SGL\")\nlibrary(\"psbcGroup\")\nlibrary(\"psbcSpeedUp\")\nlibrary(\"BhGLM\")\nlibrary(\"risksetROC\")\nlibrary(\"riskRegression\")\nlibrary(\"peperr\")\nlibrary(\"c060\")\nlibrary(\"rms\")\nlibrary(\"survAUC\")\nlibrary(\"regplot\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# download the clinical data and extract data for multiple cancers using GDC api method\ncancer_types <- c(\n  \"TCGA-BLCA\", \"TCGA-BRCA\", \"TCGA-COAD\", \"TCGA-LIHC\",\n  \"TCGA-LUAD\", \"TCGA-PAAD\", \"TCGA-PRAD\", \"TCGA-THCA\"\n)\nclin <- NULL\nfor (i in seq_along(cancer_types)) {\n  tmp <- TCGAbiolinks::GDCquery_clinic(project = cancer_types[i], type = \"clinical\")\n  clin <- rbind(clin, tmp[, c(\n    \"project\", \"submitter_id\", \"vital_status\",\n    \"days_to_last_follow_up\", \"days_to_death\",\n    \"age_at_diagnosis\", \"gender\", \"race\",\n    \"ethnicity\", \"ajcc_pathologic_t\"\n  )])\n}\n\n# extract the observed time for each patient and use years as unit\nclin$time <- apply(clin[, c(\"days_to_death\", \"days_to_last_follow_up\")], 1, max, na.rm = TRUE) / 365.25\nclin$age <- clin$age_at_diagnosis / 365.25\nclin$status <- clin$vital_status\nclin <- clin[, c(\"project\", \"submitter_id\", \"status\", \"time\", \"gender\", \"age\", \"race\", \"ethnicity\")]\n# extract patients with positive overall survival time\nclin <- clin[(clin$time > 0) & (clin$status %in% c(\"Alive\", \"Dead\")), ]\n\n# frequency table of the patients w.r.t. status, gender and ethnicity\nclin %>%\n  dplyr::count(status, gender, ethnicity) %>%\n  group_by(status) %>%\n  mutate(prop = prop.table(n))\n```\n:::\n\n\n```{.border}\n# A tibble: 12 × 5\n# Groups:   status [2]\n   status gender ethnicity                  n    prop\n   <chr>  <chr>  <chr>                  <int>   <dbl>\n 1 Alive  female hispanic or latino        75 0.0240 \n 2 Alive  female not hispanic or latino  1367 0.438  \n 3 Alive  female not reported             328 0.105  \n 4 Alive  male   hispanic or latino        34 0.0109 \n 5 Alive  male   not hispanic or latino  1041 0.334  \n 6 Alive  male   not reported             276 0.0884 \n 7 Dead   female hispanic or latino         7 0.00809\n 8 Dead   female not hispanic or latino   377 0.436  \n 9 Dead   female not reported              64 0.0740 \n10 Dead   male   hispanic or latino        10 0.0116 \n11 Dead   male   not hispanic or latino   327 0.378  \n12 Dead   male   not reported              80 0.0925 \n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# censoring plot by cancer types\nID <- 1:nrow(clin)\nclin %>%\n  ggplot(\n    aes(y = ID, x = time, colour = project, shape = factor(status))\n  ) +\n  geom_segment(aes(x = time, y = ID, xend = 0, yend = ID)) +\n  geom_point() +\n  ggtitle(\"\") +\n  labs(x = \"Years\", y = \"Patients\") +\n  scale_shape_discrete(name = \"Status\", labels = c(\"Censored\", \"Dead\")) +\n  scale_color_discrete(\n    name = \"Cancer\",\n    labels = c(\"Bladder\", \"Breast\", \"Colon\", \"Liver\", \"Lung adeno\", \"Pancreatic\", \"Prostate\", \"Thyroid\")\n  ) +\n  theme(legend.position = \"top\", legend.direction = \"vertical\") +\n  guides(color = guide_legend(nrow = 2, byrow = TRUE))\n```\n:::\n\n\n![_Overall survival times and status of pan-cancer patients from TCGA._](fig/TCGA_survival.png){width=60%}\n\n<br>\n\n## TCGA omics data {-}\n\nWe use function `GDCquery()` to query and use `GDCdownload()` and `GDCprepare()` to download TCGA omics data from one cancer type (breast cancer).\nThe argument `data.category` in function `GDCquery()` specifies the type of omics data, such as `\"Copy Number Variation\"`, `\"DNA Methylation\"`, `\"Transcriptome Profiling\"`, `\"Simple Nucleotide Variation\"`.\nNote that the downloaded omics data are accompanied by metadata including survival outcomes, clinical and demographic variables. \nThe accompanied metadata are almost the same as the clinical data downloaded via `GDCquery_clinic()` in the previous section but here only corresponding to one cancer type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# download TCGA breast cancer (BRCA) mRNA-Seq data using GDC api method\nquery <- TCGAbiolinks::GDCquery(\n  project = \"TCGA-BRCA\",\n  data.category = \"Transcriptome Profiling\",\n  data.type = \"Gene Expression Quantification\",\n  workflow.type = \"STAR - Counts\",\n  experimental.strategy = \"RNA-Seq\",\n  sample.type = c(\"Primary Tumor\")\n)\nTCGAbiolinks::GDCdownload(query = query, method = \"api\")\ndat <- TCGAbiolinks::GDCprepare(query = query)\n\nSummarizedExperiment::assays(dat)$unstranded[1:5, 1:2]\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n```{.border}\n                   TCGA-A7-A26E-01B-06R-A277-07 TCGA-A2-A0CU-01A-12R-A034-07\nENSG00000000003.15                          691                         1429\nENSG00000000005.6                            20                           73\nENSG00000000419.13                          335                         1674\nENSG00000000457.14                         1292                         1018\nENSG00000000460.17                          536                          450\n```\n\nIt is recommended to use DESeq2 or TMM normalization method for RNA-seq data before further statistical analysis [@ZhaoY2021].\nHere we demonstrate how to use the R/Bioconductor package [**DESeq2**](https://bioconductor.org/packages/DESeq2/) [@Love2014] to normalize the RNA count data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeta <- colData(dat)[, c(\"project_id\", \"submitter_id\", \"age_at_diagnosis\", \"ethnicity\", \"gender\", \"days_to_death\", \"days_to_last_follow_up\", \"vital_status\", \"paper_BRCA_Subtype_PAM50\", \"treatments\")]\nmeta$treatments <- unlist(lapply(meta$treatments, function(xx) {\n  any(xx$treatment_or_therapy == \"yes\")\n}))\ndds <- DESeq2::DESeqDataSetFromMatrix(assays(dat)$unstranded, colData = meta, design = ~1)\ndds2 <- DESeq2::estimateSizeFactors(dds)\nRNA_count <- DESeq2::counts(dds2, normalized = TRUE)\nRNA_count[1:5, 1:2]\n```\n:::\n\n\n```{.border}\n                   TCGA-A7-A26E-01B-06R-A277-07 TCGA-A2-A0CU-01A-12R-A034-07\nENSG00000000003.15                   1899.76848                   1419.51789\nENSG00000000005.6                      54.98606                     72.51561\nENSG00000000419.13                    921.01656                   1662.89219\nENSG00000000457.14                   3552.09968                   1011.24507\nENSG00000000460.17                   1473.62649                    447.01403\n```\n\nTo perform survival analysis with both clinical/demographic variables and omics data, in the following code we extract female breast cancer patients with their corresponding survival outcomes, clinical/demographic variables and RNA-seq features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeta$time <- apply(meta[, c(\"days_to_death\", \"days_to_last_follow_up\")], 1, max, na.rm = TRUE) / 365.25\nmeta$status <- meta$vital_status\nmeta$age <- meta$age_at_diagnosis / 365.25\nclin <- subset(meta, gender == \"female\" & !duplicated(submitter_id) & time > 0 & !is.na(age))\nclin <- clin[order(clin$submitter_id), ]\nRNA_count <- RNA_count[, rownames(clin)]\n```\n:::\n\n\n:::{.callout-note}\n- [Bioconductor](https://bioconductor.org/packages/release/bioc/html/TCGAbiolinks.html) might provide an outdated version of **TCGAbiolinks**. \nHere, we use the GitHub version TCGAbiolinks_2.29.6. \nIf you encounter some issues when using this tutorial, please check your installed **TCGAbiolinks** version. \nIf necessary, you can re-install the package from its [GitHub repository](https://github.com/BioinformaticsFMRP/TCGAbiolinks.git).\nOtherwise, download the data from [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.10044741.svg)](https://doi.org/10.5281/zenodo.10044741) and load the `dat` object with: `load(\"TCGA_data.rda\")`.\n\n- The package **TCGAbiolinks** cannot retrieve any proteomics or metabolomics data.\nIt is always useful to look at your data first, in particular the data type and dimensions (i.e. numbers of rows and columns for a data frame or matrix).\n:::\n\n<br>\n\n\n## Survival analysis with low-dimensional input data {-}\n\n### Nonparametric survival analysis {-}\n\nFor the data of TCGA breast cancer patients that we extracted in the previous section, Kaplan-Meier estimates of the survival probabilities can be obtained via function `survfit()` from [**survival**](https://CRAN.R-project.org/package=survival) package.\nThe dashed lines in the following figure indicate the median survival time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Kaplan-Meier (KM) estimation\nclin$status[clin$status == \"Dead\"] <- 1\nclin$status[clin$status == \"Alive\"] <- 0\nclin$status <- as.numeric(clin$status)\nsfit <- survival::survfit(Surv(time, status) ~ 1, data = clin)\n\n# calculate survival probability at 1-, 3- and 5-year time points\nsummary(sfit, times = c(1, 3, 5))\ntheme_set(theme_bw())\nggsurv <- survminer::ggsurvplot(sfit,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\",\n  legend = \"none\", surv.median.line = \"hv\"\n)\nggsurv$plot <- ggsurv$plot + annotate(\"text\", x = 20, y = 0.9, label = \"+  Censor\")\nggsurv\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Kaplan-Meier curve for 1061 BRCA patients data from TCGA._](fig/TCGA_surv_km1.png){width=60%}\n\n<br>\n\nTo compare the survival curves of two groups of patients, for example, treatment (i.e. pharmaceutical or radiation therapy) or nontreatment, the `R` function `survival::survdiff()` can perform the log-rank test to compare two survival curves.\nAlternatively, the `R` function `survival::survfit` with a formula including the treatment group as a covariate can return the (KM) survival probabilities for each groups. \nThen the `R` function `survminer::ggsurvplot()` with a `survfit` object will draw the two survival curves and perform the log-rank test as shown in the following figure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvival::survdiff(Surv(time, status) ~ treatments, data = clin)\n\nsfit2 <- survfit(Surv(time, status) ~ treatments, data = clin)\nggsurv <- ggsurvplot(sfit2,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\", legend = c(.6, .9),\n  legend.labs = c(\"No\", \"Yes\"), legend.title = \"Treatment\",\n  risk.table.y.text.col = TRUE, risk.table.y.text = FALSE\n)\nggsurv$plot <- ggsurv$plot +\n  annotate(\"text\", x = 21, y = 1, label = \"+  Censor\") +\n  annotate(\"text\", x = 22, y = .88, label = paste0(\"Log-rank test:\\n\", surv_pvalue(sfit2)$pval.txt))\nggsurv\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Kaplan-Meier curves of the BRCA patients' survival data from TCGA grouped by treatment (i.e. pharmaceutical or radiation therapy) or nontreatment. The log-rank test is to compare the two survival distributions corresponding to the two groups of patients._](fig/TCGA_surv_km2.png){width=60%}\n\n<br>\n\nTo analyze if a continuous variable, e.g. age, is associated with the survival outcomes, we can use the `R` function `coxph()` for fitting a Cox model, which is similar to the function `lm()` for fitting linear models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cox <- coxph(Surv(time, status) ~ age, data = clin)\nsummary(fit_cox)\n```\n:::\n\n```{.border}\nCall:\ncoxph(formula = Surv(time, status) ~ age, data = clin)\n\n  n= 1047, number of events= 149 \n   (14 observations deleted due to missingness)\n\n        coef exp(coef) se(coef)     z Pr(>|z|)    \nage 0.034244  1.034837 0.006703 5.109 3.24e-07 ***\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n    exp(coef) exp(-coef) lower .95 upper .95\nage     1.035     0.9663     1.021     1.049\n\nConcordance= 0.639  (se = 0.029 )\nLikelihood ratio test= 26.34  on 1 df,   p=3e-07\nWald test            = 26.1  on 1 df,   p=3e-07\nScore (logrank) test = 26.63  on 1 df,   p=2e-07\n```\n\nThe Cox model assumes proportional hazards and log-linearity of the covariates.\nTo check the log-linearity for a clinical or demographic variable, e.g. age, we can fit a penalized smoothing spline for age effect.\nThe following code shows that the nonlinear part of the smoothing spline has a significant effect ($p = 0.00013$).\nThus, the assumption of log-linearity for age is not satisfied.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cox_spline <- coxph(Surv(time, status) ~ pspline(age), data = clin)\nfit_cox_spline\n```\n:::\n\n```{.border}\nCall:\ncoxph(formula = Surv(time, status) ~ pspline(age), data = clin)\n\n                         coef se(coef)      se2    Chisq   DF       p\npspline(age), linear  0.03509  0.00577  0.00577 36.98323 1.00 1.2e-09\npspline(age), nonlin                            20.69146 3.03 0.00013\n\nIterations: 5 outer, 15 Newton-Raphson\n     Theta= 0.828 \nDegrees of freedom for terms= 4 \nLikelihood ratio test=46.4  on 4.03 df, p=2e-09\nn= 1047, number of events= 149 \n```\n\nTo check proportional hazards of age, we can add a time-dependent covariate $age \\times g(t)$, where $g(t)$ is a known function e.g. $g(t) = \\log t$.\nThe following code shows that the time-dependent age is significant using a score test ($p = 0.0087$).\nThus, the assumption of proportional hazards for age is not satisfied. The above two tests indicate a non-loglinear or time-dependent association of age with the survival outcomes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvival::cox.zph(fit_cox, transform = \"log\")\n```\n:::\n\n```{.border}\n       chisq df    p\nage     6.88  1 0.0087\nGLOBAL  6.88  1 0.0087\n```\n:::{.info-box .note}\nHere the approaches for checking log-linearity or proportional hazards can only be used in low-dimensional data settings.\nWhen including high-dimensional omics data, there are no standard approaches for checking log-linearity or proportional hazards currently.\n:::\n\n<br>\n\n### Feature preselection/filtering {-}\n\nFrom a practical point of view, since most omics profiles contain thousands of variables and most supervised statistical methods are not suited for high dimensional omics features, it is better to filter the omics features first.\nIn addition, we perceive that not too many omics features are relevant to one medical problem.\nWe will demonstrate **three different filtering approaches for high-dimensional omics data**:\n\n- Knowledge-based filtering\n- P-value-based filtering\n- Variance-based filtering\n\n#### Knowledge filter {-}\n\nOne can be interested in only some biologically meaningful genes or only protein-coding genes in a specific study. \nFor example, the code below filters protein-coding genes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_rna <- RNA_count[rowData(dat)$gene_type == \"protein_coding\", ]\n```\n:::\n\n\n#### P-value filter {-}\n\nBefore joint analyzing the associations between the thousands of omics features and survival outcomes, one can analyze the association between each omics feature and the survival outcomes, and filter omics features at a statistical significance level $0.1$ or $0.2$ (larger than 0.05 to reduce false negative identification of omics features in multivariate analysis).\nFor demonstration, based on the $100$ mRNA-Seq features from TCGA breast cancer patients preprocessed previously, the code below filters omics features at the statistical significance level $0.2$, i.e. $p < 0.2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRNA_log2count <- log2(RNA_count[1:100, ] + 1)\npvalues <- rep(NA, nrow(RNA_log2count))\nfor (j in 1:nrow(RNA_log2count)) {\n  fit_cox <- coxph(Surv(clin$time, clin$status) ~ RNA_log2count[j, ], data = clin)\n  pvalues[j] <- summary(fit_cox)$coefficients[, \"Pr(>|z|)\"]\n}\nfiltered_rna <- RNA_log2count[which(pvalues < 0.2), ]\n```\n:::\n\n\n#### Variance filter {-}\n\nThe other common and easy way to decrease the number of omics features is to filter the most variable ones for further analysis.\nNote that the variance-based filtering step should be done before data standardization (i.e. calculating $z$-score), but can be performed after count data normalization and log2-transformation for instance.\n\nThe `R` package [**M3C**](https://bioconductor.org/packages/M3C/) [@John2020] provides a filter function `featurefilter()` by using different variance-type metrics, for example, variance, median absolute deviation (MAD), coefficient of variation (A) and its second order derivative (A2).\nThe simple variance filter can be used if the variance does not change with the corresponding mean, otherwise the coefficient of variation can be used.\nIf the omics data include outliers, MAD filter is more robust than the variance filter.\nBased on the $60660$ mRNA-Seq features from TCGA breast cancer patients preprocessed previously, the code below extracts the $1\\%$ most variable features using variance as a filtering metric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRNA_log2count <- log2(RNA_count + 1)\nfiltered <- M3C::featurefilter(RNA_log2count, percentile = 1, method = \"var\", topN = 5)\nfiltered_rna1 <- filtered$filtered_data\n```\n:::\n\n```{.border}\n***feature filter function***\nextracting the most variable: 1 percent\nfeatures to start with: 60660\nperforming calculations for variance\nprinting topN most variable features with statistics...\n                              feature      mean      var       sd\nENSG00000166509.12 ENSG00000166509.12  6.086125 31.60384 5.621729\nENSG00000110484.7   ENSG00000110484.7 11.005136 26.13755 5.112489\nENSG00000153002.12 ENSG00000153002.12  8.212895 25.89105 5.088325\nENSG00000134184.13 ENSG00000134184.13  5.371435 23.23511 4.820281\nENSG00000160182.3   ENSG00000160182.3  9.902195 21.41407 4.627534\nfeatures remaining: 607\n```\n\nAnother variance-type filter is to remain features with certain percentage of **cumulative variances**, which will usually filter fewer features than the approaches above.\nThe code below extracts the most variable features explaining $1\\%$ **cumulative variances**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncumsum_var <- cumsum(filtered$statistics$var)\ncumsum_cutoff <- cumsum_var[length(cumsum_var)] * 0.01\nfiltered_names <- filtered$statistics$feature[cumsum_var < cumsum_cutoff]\n```\n:::\n\n\n<br>\n\n## Survival analysis with high-dimensional input data {-}\n\n### Unsupervised learning (omics data) {-}\n\nIn this section we will use the mRNA-Seq data of breast cancer patients from TCGA.\nThe following unsupervised methods can be applied to other omics data as well (the same applies to the supervised learning methods).\nOne important thing is that the input omics data, especially the data type and dimensions, should be suited to the methods.\n\nUnsupervised learning for omics data can be helpful to explore subpopulations of the data, for example, patients from one cancer type can be divided to several omics-related subtypes.\nWe demonstrate three unsupervised learning methods, i.e. principal component analysis (PCA), $t$-stochastic neighbour embedding ($t$-SNE) and uniform manifold approximation and projection (UMAP), based on the PAM50 genes [@Parker2009].\nThe `R` package [**M3C**](https://bioconductor.org/packages/M3C/) [@John2020] provides the analyses and visualization of all the three methods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# identify indexes of the PAM50 genes in the TCGA-BRCA data\nidx <- which(rowData(dat)$gene_name %in%\n  c(\"UBE2T\", \"BIRC5\", \"NUF2\", \"CDC6\", \"CCNB1\", \"TYMS\", \"MYBL2\", \"CEP55\", \"MELK\", \"NDC80\", \"RRM2\", \"UBE2C\", \"CENPF\", \"PTTG1\", \"EXO1\", \"ORC6\", \"ANLN\", \"CCNE1\", \"CDC20\", \"MKI67\", \"KIF2C\", \"ACTR3B\", \"MYC\", \"EGFR\", \"KRT5\", \"PHGDH\", \"CDH3\", \"MIA\", \"KRT17\", \"FOXC1\", \"SFRP1\", \"KRT14\", \"ESR1\", \"SLC39A6\", \"BAG1\", \"MAPT\", \"PGR\", \"CXXC5\", \"MLPH\", \"BCL2\", \"MDM2\", \"NAT1\", \"FOXA1\", \"BLVRA\", \"MMP11\", \"GPR160\", \"FGFR4\", \"GRB7\", \"TMEM45B\", \"ERBB2\"))\n# extract the PAM50 genes of TCGA-BRCA patients\nTCGA_PAM50 <- RNA_count[idx, ]\n# use gene symbols instead of Ensembl IDs\nrownames(TCGA_PAM50) <- rowData(dat)$gene_name[idx]\n\n# log2-transformation of the normalized count data\nTCGA_PAM50 <- log2(TCGA_PAM50 + 1)\npam50 <- factor(clin$paper_BRCA_Subtype_PAM50)\n\nM3C::pca(TCGA_PAM50, labels = pam50, dotsize = 3, legendtitle = \"Subtype\")\n```\n:::\n\n![_Unsupervised clustering (principal component analysis, PCA) of transcriptomic data from TCGA breast cancer patients_](fig/TCGA_pca.png){width=50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM3C::tsne(TCGA_PAM50, labels = pam50, dotsize = 3, legendtitle = \"Subtype\")\n```\n:::\n\n![_Unsupervised clustering ($t$-stochastic neighbour embedding, $t$-SNE) of transcriptomic data from TCGA breast cancer patients_](fig/TCGA_tsne.png){width=50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM3C::umap(TCGA_PAM50, labels = pam50, dotsize = 3, legendtitle = \"Subtype\")\n```\n:::\n\n![_Unsupervised clustering (uniform manifold approximation and projection, UMAP) of transcriptomic data from TCGA breast cancer patients_](fig/TCGA_umap.png){width=50%}\n\n<br>\n\n### Supervised learning (omics and survival data) {-}\n\nTo investigate the relationship between omics features and survival outcomes, regression methods (i.e. supervised learning) can be applied. \nSince omics data are high-dimensional, one can use unsupervised learning methods to summarize a few components (dimension reduction) and regress the survival outcomes on the low-dimensional components by some classical statistical methods, e.g. classical Cox model.\nThere are also frequentist and Bayesian supervised learning methods suited to directly regress the survival outcomes on the high-dimensional omics features.\nNote that preselecting/filtering ultrahigh-dimensional omics features can be useful before running the frequentist and Bayesian supervised learning methods.\n\n#### Dimension reduction for Cox models {-}\n\nThe following code demonstrates the use of the first two principal components of PCA as covariates for the **purpose of survival prediction**.\nSimilarly, the first components from $t$-SNE or UMAP can also be extracted as covariates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# principal component regression\nx_tmp <- prcomp(t(TCGA_PAM50))\n\n# choose the top two components (subjective) as covariates\nX_PC <- x_tmp$x[, 1:2]\n# build classical survival model (e.g. PH Cox model)\ndata_tmp <- data.frame(time = clin$time, status = clin$status, X_PC)\nfit <- coxph(Surv(time, status) ~ PC1 + PC2, data = data_tmp)\nsummary(fit)\n```\n:::\n\n```{.border}\nCall:\ncoxph(formula = Surv(time, status) ~ PC1 + PC2, data = data_tmp)\n\n  n= 1047, number of events= 149 \n\n        coef exp(coef) se(coef)     z Pr(>|z|)   \nPC1 0.004679  1.004690 0.009675 0.484  0.62862   \nPC2 0.038179  1.038918 0.013233 2.885  0.00391 **\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n    exp(coef) exp(-coef) lower .95 upper .95\nPC1     1.005     0.9953    0.9858     1.024\nPC2     1.039     0.9625    1.0123     1.066\n\nConcordance= 0.58  (se = 0.028 )\nLikelihood ratio test= 8.54  on 2 df,   p=0.01\nWald test            = 8.64  on 2 df,   p=0.01\nScore (logrank) test = 8.66  on 2 df,   p=0.01\n```\n\n#### Penalized Cox models {-}\n\nFor computational efficiency, we will use only the mRNA-Seq features corresponding to the PAM50 genes [@Parker2009] instead of the variance filtered genes from the previous section.\nWe perform an investigation of the relationships between the mRNA-Seq features, two clinical variables (i.e. the patients' age at diagnosis and their ethnicity) and the survival outcomes.\n\nThe `R` package [**glmnet**](https://CRAN.R-project.org/package=glmnet) [@Friedman2010] is very computationally efficient to run Lasso and Elastic Net Cox models.\nLasso has a tuning parameter $\\lambda$ to control the penalty strength of the coefficients which can be optimized by cross-validation (CV) via function `cv.glmnet()`.\nThe `glmnet()` and `cv.glmnet()` functions provide the argument `penalty.factor` to allow different shrinkage for different features, which makes sense if one includes both clinical/demographic variables and omics features and does not want to perform feature selection for the clinical/demographic variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Lasso Cox model\n\n## for demonstration simplicity, PAM50 genes are used here\nx <- cbind(age = clin$age, ethnicity = factor(clin$ethnicity), t(TCGA_PAM50))\ny <- cbind(time = clin$time, status = clin$status)\n\n# set penalty factor without penalizing the two demographical variables\npf <- c(rep(0, 2), rep(1, ncol(x) - 2))\n\n# Lasso Cox by using cv.glmnet to obtain the 5-fold CV optimal lambda.min or lambda.1se\nset.seed(123)\ncvfit <- glmnet::cv.glmnet(x, y, family = \"cox\", nfolds = 5, penalty.factor = pf)\nmod <- cvfit$glmnet.fit\nlambda_optimal <- cvfit$lambda.min # optimal lambda\n\nbetas <- as.vector(coef(mod, s = lambda_optimal))\nbeta.positive <- colnames(x)[betas > 0]\nbeta.negative <- colnames(x)[betas < 0]\n# get ordered list of variables as they appear at smallest lambda\nallnames <- names(coef(mod)[, ncol(coef(mod))]\n[order(coef(mod)[, ncol(coef(mod))], decreasing = TRUE)])\n# assign colors for positive (pink) and negative (green) coefficients\ncols <- rep(\"gray80\", length(allnames))\ncols[allnames %in% beta.positive] <- \"seagreen3\"\ncols[allnames %in% beta.negative] <- \"hotpink\"\n\n# draw coefficient paths of a Lasso Cox model\nplotmo::plot_glmnet(mod,\n  label = TRUE, s = lambda_optimal, col = cols,\n  xlab = expression(log ~ ~lambda), ylab = expression(beta)\n)\ntitle(\"Lasso    \\n\\n\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Coefficient paths of a Lasso Cox model. The verticle gray line indicates the optimal $\\lambda$ and its correspondingly selected features are marked as green (positive coefficient) and red (negative coefficient) colors. Note that the demographic variables age and ethnicity were not penalized, so that their coefficient paths did not start from zero in the figure._](fig/TCGA_lasso.png){width=60%}\n\n<br>\n\nElastic Net Cox model includes the $\\lambda$ and an additional penalty parameter $\\alpha \\in [0,1]$.\nThe parameter $\\alpha$ can be fixed as $0$ (Ridge), $1$ (Lasso) or any value between $0$ and $1$ for making a compromise between Ridge and Lasso, which can also be optimized by cross-validation manually, see the example below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Elastic Net Cox model\n\n# set penalty parameter alpha which comprises between Lasso and ridge regressions\nalpha <- seq(0.1, 1, length = 10)\nfitEN <- list()\nset.seed(123)\nfor (i in 1:length(alpha)) {\n  fitEN[[i]] <- cv.glmnet(x, y, family = \"cox\", alpha = alpha[i], nfolds = 5, penalty.factor = pf)\n}\nidx <- which.min(sapply(fitEN, function(xx) {\n  xx$cvm[xx$lambda == xx$lambda.min]\n}))\ncvfit <- fitEN[[idx]]\n\n# the following code is the same as Lasso previously\nmod <- cvfit$glmnet.fit\nlambda_optimal <- cvfit$lambda.min # optimal lambda\n\nbetas <- as.vector(coef(mod, s = lambda_optimal))\nbeta.positive <- colnames(x)[betas > 0]\nbeta.negative <- colnames(x)[betas < 0]\nallnames <- names(coef(mod)[, ncol(coef(mod))]\n[order(coef(mod)[, ncol(coef(mod))], decreasing = TRUE)])\ncols <- rep(\"gray80\", length(allnames))\ncols[allnames %in% beta.positive] <- \"seagreen3\"\ncols[allnames %in% beta.negative] <- \"hotpink\"\n\nplotmo::plot_glmnet(mod,\n  label = TRUE, s = lambda_optimal, col = cols,\n  xlab = expression(log ~ ~lambda), ylab = expression(beta)\n)\ntitle(\"Elastic Net     \\n\\n\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Coefficient paths of an Elastic Net Cox model. The verticle gray line indicates the optimal $\\lambda$ and its correspondingly selected features are marked as green (positive coefficient) and red (negative coefficient) colors. Note that the demographic variables age and ethnicity were not penalized, so that their coefficient paths did not start from zero in the figure._](fig/TCGA_elastic.png){width=60%}\n\n<br>\n\nAdaptive Lasso Cox model needs to pre-estimate all coefficients which will be used as weights via the argument `penalty.factor` in the `glmnet()` and `cv.glmnet()` functions to fit a Lasso Cox model.\nThe pre-estimation can be done by a Ridge Cox model, see an example below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Adaptive Lasso Cox model\n\nset.seed(123)\nfit <- cv.glmnet(x, y, family = \"cox\", alpha = 0, nfolds = 5)\nweights <- abs(1 / as.vector(coef(fit, s = \"lambda.min\")))\nweights[c(1,2)] = 0 # don't penalize age and ethnicity\n\n# adaptive Lasso Cox by using cv.glmnet to obtain the 5-fold CV optimal lambda.min or lambda.1se\ncvfit <- cv.glmnet(x, y, family = \"cox\", nfolds = 5, penalty.factor = weights)\nmod <- cvfit$glmnet.fit\nlambda_optimal <- cvfit$lambda.min # optimal lambda\n\nbetas <- as.vector(coef(mod, s = lambda_optimal))\nbeta.positive <- colnames(x)[betas > 0]\nbeta.negative <- colnames(x)[betas < 0]\n# get ordered list of variables as they appear at smallest lambda\nallnames <- names(coef(mod)[, ncol(coef(mod))]\n[order(coef(mod)[, ncol(coef(mod))], decreasing = TRUE)])\n# assign colors\ncols <- rep(\"gray80\", length(allnames))\ncols[allnames %in% beta.positive] <- \"seagreen3\"\ncols[allnames %in% beta.negative] <- \"hotpink\"\n\nplot_glmnet(mod,\n  label = TRUE, s = lambda_optimal, col = cols,\n  xlab = expression(log ~ lambda), ylab = expression(beta)\n)\ntitle(\"Adative Lasso    \\n\\n\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Coefficient paths of an adaptive Lasso Cox model. The verticle gray line indicates the optimal $\\lambda$ and its correspondingly selected features are marked as green (positive coefficient) and red (negative coefficient) colors. Note that the demographic variables age and ethnicity were not penalized, so that their coefficient paths did not start from zero in the figure._](fig/TCGA_adaptiveLasso.png){width=60%}\n\n<br>\n\nGroup Lasso Cox model can be implemented through the `R` package [**grpreg**](https://CRAN.R-project.org/package=grpreg) [@Breheny2015].\nFor an illustration, we specify the two demographic variables as the first group, the first $10$ PAM50 genes as the second group, the last $40$ PAM50 genes as the third group.\nA $k$-fold cross-validation (CV) for the group Lasso Cox model is performed through function `cv.grpsurv()`.\nThe returned object `cvfit$lambda.min` is the value of CV-optimized $\\lambda$.\nThe following results show that \n\n- when choosing the CV-optimized $\\lambda = 0.0143$ (output matrix has lambda values as column names), the estimated coefficients of the first two groups are nonzero (i.e. selecting first and second groups);\n- when choosing the $10$-th lambda $\\lambda = 0.0217$, only the first group of covariates has nonzero coefficients (i.e. selecting first group);\n- when choosing the $15$-th lambda $\\lambda = 0.0108$, the estimated coefficients of all the three groups are nonzero (i.e. selecting all groups). \n\nNote that the `R` package [**grpreg**](https://CRAN.R-project.org/package=grpreg) [@Breheny2015] also implements group smoothly clipped absolute deviation (SCAD) model and some others, see @Breheny2021 for details.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# group Lasso Cox model\ngroup <- c(rep(\"demographic\", 2), rep(\"PAM50_1\", 10), rep(\"PAM50_2\", 40))\ngroup <- factor(group)\nset.seed(123)\ncvfit <- grpreg::cv.grpsurv(X = x, y = y, group = group, penalty = \"grLasso\", returnY = TRUE)\nround(cvfit$fit$beta[, c(which.min(cvfit$cve), 10, 20)], digits = 4)\n```\n:::\n\n```{.border}\n           0.0143  0.0217  0.0108\nage        0.0218  0.0154  0.0247\nethnicity -0.0542 -0.0425 -0.0570\nANLN       0.0193  0.0000  0.0713\nFOXC1     -0.0032  0.0000 -0.0104\nCDH3      -0.0028  0.0000 -0.0090\nUBE2T      0.0154  0.0000  0.0571\nNDC80     -0.0239  0.0000 -0.0862\nPGR       -0.0027  0.0000 -0.0086\nBIRC5     -0.0133  0.0000 -0.0497\nORC6       0.0140  0.0000  0.0489\nESR1      -0.0002  0.0000 -0.0008\nPHGDH      0.0008  0.0000  0.0024\nCDC6       0.0000  0.0000 -0.0094\nMMP11      0.0000  0.0000  0.0074\nMYBL2      0.0000  0.0000  0.0018\nSFRP1      0.0000  0.0000  0.0049\nCCNE1      0.0000  0.0000  0.0000\nBLVRA      0.0000  0.0000 -0.0436\nBAG1       0.0000  0.0000 -0.0163\nMLPH       0.0000  0.0000 -0.0155\nCDC20      0.0000  0.0000 -0.0129\nCENPF      0.0000  0.0000 -0.0245\nKRT17      0.0000  0.0000 -0.0125\nFOXA1      0.0000  0.0000  0.0040\nACTR3B     0.0000  0.0000 -0.0112\nCCNB1      0.0000  0.0000  0.0302\nMDM2       0.0000  0.0000 -0.0077\nMYC        0.0000  0.0000  0.0002\nCEP55      0.0000  0.0000 -0.0242\nSLC39A6    0.0000  0.0000  0.0053\nERBB2      0.0000  0.0000 -0.0089\nGRB7       0.0000  0.0000  0.0099\nKIF2C      0.0000  0.0000  0.0219\nNUF2       0.0000  0.0000  0.0210\nEGFR       0.0000  0.0000 -0.0150\nMKI67      0.0000  0.0000  0.0266\nTMEM45B    0.0000  0.0000  0.0100\nFGFR4      0.0000  0.0000  0.0023\nPTTG1      0.0000  0.0000  0.0095\nMELK       0.0000  0.0000 -0.0188\nNAT1       0.0000  0.0000 -0.0052\nCXXC5      0.0000  0.0000  0.0131\nBCL2       0.0000  0.0000 -0.0082\nRRM2       0.0000  0.0000 -0.0003\nGPR160     0.0000  0.0000 -0.0043\nEXO1       0.0000  0.0000  0.0041\nUBE2C      0.0000  0.0000 -0.0052\nTYMS       0.0000  0.0000 -0.0298\nKRT5       0.0000  0.0000 -0.0025\nKRT14      0.0000  0.0000  0.0085\nMAPT       0.0000  0.0000 -0.0071\nMIA        0.0000  0.0000 -0.0180\n```\n\nSparse group Lasso Cox model is implemented in the `R` package [**SGL**](https://CRAN.R-project.org/package=SGL) [@Simon2019]. \nThe function `cvSGL()` uses cross validation to optimize the penalty parameter $\\lambda$.\nThe following example shows that it induces sparsity in each group of covariates. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sparse group Lasso Cox model\ngroup <- c(rep(\"demographic\", 2), rep(\"PAM50_1\", 10), rep(\"PAM50_2\", 40))\ngroup <- factor(group)\ndat_tmp <- list(x = x, time = clin$time, status = clin$status)\nset.seed(123)\ncvfit <- SGL::cvSGL(dat_tmp, index = group, type = \"cox\", nfold = 5)\nbeta.hat <- cvfit$fit$beta[, which.min(cvfit$lldiff)]\nnames(beta.hat) <- paste0(\"group\", as.numeric(group), \".\", c(1:2, 1:10, 1:40))\nbeta.hat\n```\n:::\n\n```{.border}\n     group1.1      group1.2      group2.1      group2.2      group2.3      group2.4 \n 5.6584838488  0.0000000000  0.4812006103  0.0000000000  0.0000000000  0.2481830177 \n     group2.5      group2.6      group2.7      group2.8      group2.9     group2.10 \n 0.0000000000 -0.0003042126  0.0000000000  0.3317385412  0.0000000000  0.0000000000 \n     group3.1      group3.2      group3.3      group3.4      group3.5      group3.6 \n 0.0000000000  0.3037631224  0.0000000000 -0.3782338997  0.0000000000 -2.6805881347 \n     group3.7      group3.8      group3.9     group3.10     group3.11     group3.12 \n-1.8418523757  0.0000000000  0.0000000000  0.0000000000 -1.7849923007  0.0000000000 \n    group3.13     group3.14     group3.15     group3.16     group3.17     group3.18 \n 0.0000000000  1.0290918041  0.0000000000  0.0000000000  0.0000000000  0.0000000000 \n    group3.19     group3.20     group3.21     group3.22     group3.23     group3.24 \n 0.0000000000  0.0000000000  0.0000000000  0.0000000000 -0.3679980817  0.0000000000 \n    group3.25     group3.26     group3.27     group3.28     group3.29     group3.30 \n 0.9925901529  0.0088469957  0.0000000000  0.0000000000  0.0000000000  0.0000000000 \n    group3.31     group3.32     group3.33     group3.34     group3.35     group3.36 \n-2.1975942364  0.0000000000  0.0000000000  0.0000000000  0.0000000000 -0.8407228093 \n    group3.37     group3.38     group3.39     group3.40 \n-1.8217490477  0.0000000000 -0.7323739107 -2.0111900380 \n```\n\n#### Sparse Bayesian Cox models\n\nThe `R` package [**psbcGroup**](https://CRAN.R-project.org/package=psbcGroup) [@Lee2021] integrates a large set of sparse Bayesian Cox models. \nThe function `psbcGL()` implements Bayesian Cox models with Lasso and group Lasso priors for feature selection and group selection respectively. \nFor the Lasso prior, set the hyperparameter `priorPara$groupInd = 1:p` where $p$ is the total number of covariates. \nFor the group Lasso prior, set the hyperparameter `priorPara$groupInd` as a vector of size $p$, where each element denotes which group each covariate corresponds to. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bayesian Cox model with Lasso prior\n\nset.seed(123)\nsurvObj <- list(t = clin$time, di = clin$status, x = x)\np <- ncol(x)\n# set hyperparameters.\n# For Lasso prior (i.e. 'groupInd'= 1:p), larger ratio r/delta tends to force the posterior betas to be more concentrated at 0\n# For group Lasso prior (i.e. 'groupInd' as group indicator for covariates), larger ratio r/delta tends to force stronger grouping effect of covariates\ns <- c(sort(survObj$t[survObj$di == 1]), 2 * max(survObj$t) - max(survObj$t[-which(survObj$t == max(survObj$t))]))\npriorPara <- list(\n  \"eta0\" = 1, \"kappa0\" = 1, \"c0\" = 2, \"r\" = 0.5,\n  \"delta\" = 0.0001, \"s\" = s, \"J\" = length(s), \"groupInd\" = 1:p\n)\n# set MCMC parameters\nmcmcPara <- list(\"numBeta\" = p, \"beta.prop.var\" = 1)\n# set initial values of hyperparameters\nlambdaSq <- 1\ninitial <- list(\n  \"beta.ini\" = rep(0, p), \"lambdaSq\" = 1, \"sigmaSq\" = runif(1, 0.1, 10),\n  \"tauSq\" = rexp(length(unique(priorPara$groupInd)), \"rate\" = lambdaSq / 2),\n  \"h\" = rgamma(priorPara$J, 1, 1)\n)\n# in real applications, 'num.reps' should be large enough (e.g. 20000, 40000) and 'chain' to be > 1\n# argument 'rw' should be FALSE for high-dimensional covariates\nBayesLassofit <- psbcGroup::psbcGL(survObj, priorPara, initial, rw = TRUE, mcmcPara, num.reps = 100, thin = 1, chain = 1)\n# burn-in the first half MCMC iterations\nbeta_p <- BayesLassofit$beta.p[-(1:51), ]\ncolnames(beta_p) <- colnames(x)\npsbcSpeedUp:::plot.psbcSpeedUp(beta_p)\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Estimates of regression coefficients by a penalized semiparametric Bayesian Cox model with Lasso prior. Solid dots indicate the posterior mean over MCMC iterations (excluding burn-in period), and horizontal lines show the corresponding 95% credibility intervals._](fig/TCGA_bayeslasso.png){width=50%}\n\n<br>\n\nNote that **psbcGroup** cannot distinguish mandatory (unpenalized) covariates with omics features, see @Zucknick2015 for an extended Bayesian Lasso Cox model. []{#psbcSpeedUp} \nThe following code implements the Bayesian Lasso Cox model with mandatory covariates through the `R` package [**psbcSpeedUp**](https://CRAN.R-project.org/package=psbcSpeedUp) [@Zhao2023b]. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bayesian Cox model with Lasso prior and mandatory covariates\nset.seed(123)\nsurvObjM <- list(t = clin$time, di = clin$status, x = x[, c(3:52, 1:2)])\npriorPara <- list(\"eta0\" = 1, \"kappa0\" = 1, \"c0\" = 2, \"r\" = 0.5, \"delta\" = 0.0001)\nBayesLassoMfit <- psbcSpeedUp::psbcSpeedUp(survObjM,\n  p = 50, q = 2, hyperpar = priorPara,\n  nIter = 100, burnin = 50, thin = 1, rw = FALSE, outFilePath = \"tmp\"\n)\nplot(BayesLassoMfit)\n```\n:::\n\n```{.border}\nRunning MCMC iterations ...\n[##################################################] 100%\nDONE, exiting! \n```\n\n::: {.cell}\n\n:::\n\n![_Estimates of regression coefficients by a penalized semiparametric Bayesian Cox model with Lasso prior and unpenalized covariates. Solid dots indicate the posterior mean over MCMC iterations (excluding burn-in period), and horizontal lines show the corresponding 95% credibility intervals._](fig/TCGA_bayesLassoM.png){width=50%}\n\n<br>\n\nIn the `R` package [**psbcGroup**](https://CRAN.R-project.org/package=psbcGroup) [@Lee2021], function `psbcEN()` implements Bayesian Cox models with Elastic Net prior for feature selection with grouping effect of correlated features.\nFunction `psbcFL()` implements Bayesian Cox models with fused Lasso prior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bayesian Cox model with Elastic Net prior\nset.seed(123)\n# set hyperparameters\n# Larger ratio r1/delta1 forces the posterior betas to be more concentrated at 0\n# Larger ratio r2/delta2 forces stronger grouping effect of covariates\npriorPara <- list(\n  \"eta0\" = 1, \"kappa0\" = 1, \"c0\" = 2, \"r1\" = 0.1, \"r2\" = 1,\n  \"delta1\" = 0.1, \"delta2\" = 1, \"s\" = s, \"J\" = length(s)\n)\n# set MCMC parameters\nmcmcPara <- list(\"numBeta\" = p, \"beta.prop.var\" = 1)\n# set initial values of hyperparameters\ninitial <- list(\n  \"beta.ini\" = rep(0, p), \"lambda1Sq\" = 1, \"lambda2\" = 1, \"sigmaSq\" = runif(1, 0.1, 10),\n  \"tauSq\" = rexp(p, rate = 1 / 2), \"h\" = rgamma(priorPara$J, 1, 1)\n)\n# in real application, 'num.reps' should be large enough (e.g. 20000, 40000) and 'chain' to be > 1\nBayesENfit <- psbcEN(survObj, priorPara, initial, rw = FALSE, mcmcPara, \n                     num.reps = 100, thin = 1, chain = 1)\n# burn-in the first half MCMC iterations\nEN_beta_p <- BayesENfit$beta.p[52:101, ]\ncolnames(EN_beta_p) <- colnames(x)\npsbcSpeedUp:::plot.psbcSpeedUp(EN_beta_p)\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Estimates of regression coefficients by a penalized semiparametric Bayesian Cox model with Elastic Net prior. Solid dots indicate the posterior mean over MCMC iterations (excluding burn-in period), and horizontal lines show the corresponding 95% credibility intervals._](fig/TCGA_bayesEN.png){width=50%}\n\n<br>\n\nA penalized semiparametric Bayesian Cox model with double exponential spike-and-slab prior is implemented in the `R` package [**BhGLM**](https://github.com/nyiuab/BhGLM.git) [@Yi2019]. Note that **BhGLM** provides frequentist confidence intervals of the posterior mode of the coefficients.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# penalized semiparametric Bayesian Cox model with (double exponential) spike-and-slab prior\ny_surv <- Surv(clin$time, clin$status)\nx_dataframe <- as.data.frame(x)\nset.seed(123)\nBayesfit <- BhGLM::bcoxph(y_surv ~ ., x_dataframe, prior = mde(0, 0.01, 0.8), control = coxph.control(iter.max = 200))\nBhGLM::plot.bh(Bayesfit, col.pts = c(\"red\", \"blue\"), main = \"Cox with mixture double exponential\\n\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Coefficient estimates of a penalized semiparametric Bayesian Cox model with (double exponential) spike-and-slab prior. Solid dots denote the posterior mode of the coefficients and lines denote the 95% confidence intervals. Red colored text on the right side mark the significant features with $p < 0.05$._](fig/TCGA_bayesSpikeSlab.png){width=60%}\n\n## Survival model validation {-}\n\nThe ideal evaluation of a prognostic model is based on completely independent validation data, since high-dimensional survival models built on the training data can be overfitted. \nIf there are no independent validation data, it is recommended to use resampling-based methods for estimating the **uncertainty** of the model’s prediction performance. \nThis can be done for example by repeatedly splitting the dataset to training/validation sets and evaluating a model’s performance on the different validation sets using various evaluation metrics. \n\n:::{.callout-tip}\n## Model validation\nTo validate a prediction model systematically, the predictive performance of the model is commonly addressed by\n\n  - **Discrimination**: the ability of the model to distinguish between low and high risk patients\n  - **Calibration**: the agreement between the observed and predicted survival probabilities\n  - **Overall performance**: the distance between the observed and predicted survival probabilities\n:::\n\nThe performance metrics can be *time-dependent* or *time-independent*, with the time-dependent metrics being more informative in general compared to integrated measures (i.e. evaluated across many time points).\nFor survival data, we can assess the **discriminatory power** of a model (i.e. how well does it ranks patients) or how well a model is **calibrated** (i.e. how closely the predicted survival probabilities agree numerically with the actual survival outcomes).\nFor example, measures such as the receiver operating characteristic (ROC) curve, the (integrated) area under time-specific ROC curves (**AUC**, @Heagerty2005) and the concordance index (**C-index**, @Harrell1982) are measures of discrimination, while the right-censored logarithmic loss (**RCLL**, @Avati2020) and the well-known **Brier score** [@Graf1999] are used to evaluate both discrimination and calibration performance.\n\n### Model evaluation (classic) {-}\n\n:::{.callout-note}\n'Classic' here refers to the use of manual `R` code in combination with many separate `R` packages which have been routinely used in academia the latest 10+ years for evaluating survival models.\n:::\n\nTo evaluate the performance of a statistical model, we first split the data into training and validation data sets.\nFor example, we can randomly split the 1047 BRCA patients from TCGA into $80\\%$ as training set and $20\\%$ as validation set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nn <- nrow(x)\nidx <- sample(1:n, n * 0.8, replace = FALSE)\nx_train <- x[idx, ]\ny_train <- y[idx, ]\nx_validate <- x[-idx, ]\ny_validate <- y[-idx, ]\n```\n:::\n\n\n:::{.callout-important}\nThe $20\\%$ split of a dataset is often not considered an **independent** dataset and **resampling-based methods** should be used in such cases to provide an unbiased estimate of the predictive accuracy of a prognostic model.\n:::\n\n#### Discrimination metrics {-}\n\n<font size=\"4\"> **Goodness-of-fit** </font> \n\nThe simplest way to demonstrate the prognostic power of a survival model is to dichotomize the prognostic scores (i.e., linear predictor $lp$ in the Cox model) by median value, and then to use a log-rank test to compare the survival curves of the patients in the two groups.\nWe use the built model to predict the prognostic scores based on the $20\\%$ validation data.\nThe following code shows the **goodness-of-fit** of a Lasso Cox model with the BRCA patients survival and PAM50 mRNA-Seq data from TCGA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# train a Lasso Cox model, similarly for other Cox-type models\nset.seed(123)\ncvfit <- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\npred_lp <- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n\n# dichotomize by prognostic scores (linear predictor)  by median to divide the validation patients into two groups\ngroup_dichotomize <- as.numeric(pred_lp > median(pred_lp))\n\n# draw two survival curves based on KM estimation and compare them by a log-rank test\ndat_tmp <- data.frame(time = y_validate[, 1], status = y_validate[, 2], group = group_dichotomize)\nsfit <- survfit(Surv(time, status) ~ group, data = dat_tmp)\n\nggsurv <- ggsurvplot(sfit,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\", legend = c(.2, .3),\n  legend.labs = c(\"Low risk\", \"High risk\"), legend.title = \"Dichotomized groups\",\n  risk.table.y.text.col = TRUE, risk.table.y.text = FALSE\n)\nggsurv$plot <- ggsurv$plot +\n  annotate(\"text\", x = 2.6, y = .03, label = paste0(\"Log-rank test:\\n\", surv_pvalue(sfit)$pval.txt))\nggsurv$table <- ggsurv$table + labs(y = \"Dichotomized\\n groups\")\nggsurv\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Kaplan-Meier curves of the BRCA patients data dichotomized by the median of prognostic scores (calculated from the Lasso Cox model with patients' survival and mRNA-Seq data) into two groups. The log-rank test is to compare the two survival distributions corresponding to the two groups of patients._](fig/TCGA_surv_km_lasso.png){width=50%}\n\n<br>\n\nThe prognostic scores can also be divided into three or more groups based on quantiles and the log-rank test can be used to compare the difference of multiple survival curves.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup <- pred_lp\ngroup[pred_lp >= quantile(pred_lp, 2 / 3)] <- 3\ngroup[pred_lp >= quantile(pred_lp, 1 / 3) & pred_lp < quantile(pred_lp, 2 / 3)] <- 2\ngroup[pred_lp < quantile(pred_lp, 1 / 3)] <- 1\n\n# draw two survival curves based on KM estimation and compare them by a log-rank test\ndat_tmp <- data.frame(time = y_validate[, 1], status = y_validate[, 2], group = group)\nsfit <- survfit(Surv(time, status) ~ group, data = dat_tmp)\n\nggsurv <- ggsurvplot(sfit,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\", legend = c(.2, .3),\n  legend.labs = c(\"Low risk\", \"Middle risk\", \"High risk\"), legend.title = \"Groups\",\n  risk.table.y.text.col = TRUE, risk.table.y.text = FALSE\n)\nggsurv$plot <- ggsurv$plot +\n  annotate(\"text\", x = 3.5, y = .05, label = paste0(\"Log-rank test:\\n\", surv_pvalue(sfit)$pval.txt))\nggsurv\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Kaplan-Meier curves of the BRCA patients data divided by 33% and 67% quantiles of prognostic scores (calculated from the Lasso Cox model with patients' survival and mRNA-Seq data) into three groups. The log-rank test is to compare the two survival distributions corresponding to the three groups of patients._](fig/TCGA_surv_km_lasso2.png){width=50%}\n\n<br>\n\n<font size=\"4\"> **ROC curve** </font> \n\nThe `R` package [**risksetROC**](https://CRAN.R-project.org/package=risksetROC) [@Heagerty2005] can estimate a ROC curve at an evaluation time point. \nThe following code draws a ROC curve at 5-years survival evaluation time point for the 20% TCGA validation data and based on a Lasso Cox model learned from the 80% training data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nROC <- risksetROC(\n  Stime = y_validate[, 1], status = y_validate[, 2],\n  marker = pred_lp, predict.time = 5, method = \"Cox\",\n  main = \"ROC Curve\", col = \"seagreen3\", type = \"s\",\n  lwd = 2, xlab = \"1 - Specificity\", ylab = \"Sensitivity\"\n)\ntext(0.7, 0.2, paste(\"AUC =\", round(ROC$AUC, 3)))\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_ROC curve estimated at 5-years survival evaluation time point for the 20% TCGA validation data and based on a Lasso Cox model learned from the 80% training data. The AUC value is the area under the ROC curve. The diagonal line represents the performance of a random prediction of the outcome event with AUC = 0.5._](fig/TCGA_surv_roc.png){width=40%}\n\n<br>\n\n<font size=\"4\"> **Time-dependent AUC** </font> \n\nBoth time-dependent and integrated AUCs can be estimated by the `R` package [**risksetROC**](https://CRAN.R-project.org/package=risksetROC). \nWe demonstrate the calculation based on both training and validation data.\n\n:::{.callout-note}\n## Survival prediction in Cox models\n\nA Cox proportional hazards model (and Lasso Cox as a consequence) is a semi-parametric model, which means that it does not produce survival distribution predictions by default.\nHowever, using the function `risksetROC::CoxWeights()` you can transform the `cv.glmnet`'s output linear predictors (`lp`) to survival distribution predictions.\nThis transformation internally uses the **Breslow estimator** for the cumulative baseline hazard.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# unique event times for patients in the training and validation data sets\nutimes_train <- sort(unique(y_train[y_train[, 2] == 1, 1]))\nutimes_validate <- sort(unique(y_validate[y_validate[, 2] == 1, 1]))\n\n# markers from the estimated linear predictors of a Lasso Cox model\npred_lp_train <- predict(cvfit, newx = x_train, s = cvfit$lambda.min, type = \"link\")\npred_lp_validate <- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n\n## compute time-dependent AUC\nAUC_train <- rep(NA, length(utimes_train))\nAUC_validate <- rep(NA, length(utimes_validate))\nfor (j in 1:length(utimes_train)) {\n  out <- risksetROC::CoxWeights(\n    marker = pred_lp_train, Stime = y_train[, 1],\n    status = y_train[, 2], predict.time = utimes_train[j]\n  )\n  AUC_train[j] <- out$AUC\n}\nfor (j in 1:length(utimes_validate)) {\n  out <- risksetROC::CoxWeights(\n    marker = pred_lp_validate, Stime = y_validate[, 1],\n    status = y_validate[, 2], predict.time = utimes_validate[j]\n  )\n  AUC_validate[j] <- out$AUC\n}\n\n# draw the time-dependent AUC from the training and validation data sets\ndat_AUC <- data.frame(\n  tAUC = c(AUC_train, AUC_validate),\n  times = c(utimes_train, utimes_validate),\n  group = c(rep(\"AUC_train\", length(AUC_train)), rep(\"AUC_validate\", length(AUC_validate)))\n)\nggplot(dat_AUC, aes(times, tAUC, group = group, color = group)) +\n  xlab(\"Evaluation time points (year)\") +\n  ylab(\"AUC\") +\n  ylim(0.5, 1) +\n  geom_step(direction = \"vh\") +\n  theme(legend.position = c(0.7, 0.8), legend.title = element_blank())\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Time-dependent AUC based on a Lasso Cox model applied to the BRCA patients data from TCGA. The red line shows the Time-dependent AUC calculated from the 80% training data, and the green line shows the Time-dependent AUC calculated from the 20% validation data._](fig/TCGA_surv_auc_lasso.png){width=40%}\n\n<br>\n\n<font size=\"4\"> **Integrated AUC** </font> \n\nThe `R` package [**risksetROC**](https://CRAN.R-project.org/package=risksetROC) [@Heagerty2005] provides function `IntegrateAUC()` to estimate integrated AUC.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Before computing integrated AUC, first estimate survival probabilities at unique survival times\nsurv_prob_train <- unique(survfit(Surv(y_train[, 1], y_train[, 2]) ~ 1)$surv)\nsurv_prob_validate <- unique(survfit(Surv(y_validate[, 1], y_validate[, 2]) ~ 1)$surv)\n\n## integrated AUC (e.g. over tmax=10 years) to get concordance measure based on training data\n(iAUC_train <- risksetROC::IntegrateAUC(AUC_train, utimes_train, surv_prob_train, tmax = 10))\n```\n:::\n\n```{.border}\n[1] 0.6279646\n```\n\n::: {.cell}\n\n```{.r .cell-code}\n## integrated AUC (e.g. over tmax=10 years) to get concordance measure based on validation data\n(iAUC_validate <- risksetROC::IntegrateAUC(AUC_validate, utimes_validate, surv_prob_validate, tmax = 10))\n```\n:::\n\n```{.border}\n[1] 0.6318253\n```\n\n<font size=\"4\"> **Time-dependent C-index** </font> \n\nThe C-index is not proper for $t$-year predictions, see @Blanche2019.\nConsider using time-dependent AUC or time-dependent Brier score instead.\nFor a time-dependent discrimination index for survival data, see @Antolini2005.\n\n<font size=\"4\"> **C-index** </font> \n\nThe `R` package [**glmnet**](https://CRAN.R-project.org/package=glmnet) provides the function `glmnet::Cindex()` to estimate Harrell's C-index from a \"coxnet\" object.\nThe `R` package [**survAUC**](https://CRAN.R-project.org/package=survAUC) provides the function `survAUC::UnoC()` to estimated Uno's C-index.\nSee an example calculation for both C-indexes using a Lasso Cox model below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ncvfit <- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\npred <- predict(cvfit, newx = x_validate, type = \"link\", s = cvfit$lambda.min)\n# Harrell's C-index\n(Cindex_Harrell <- Cindex(pred = pred[, 1], y = y_validate))\n```\n:::\n\n```{.border}\n[1] 0.7246466\n```\n\n::: {.cell}\n\n```{.r .cell-code}\n# Uno's C-index\n(Cindex_Uno <- survAUC::UnoC(y_train, y_validate, pred))\n```\n:::\n\n```{.border}\n[1] 0.5772041\n```\n\n<br>\n\n#### Calibration metrics {-}\n\nSee a [calibration plot](#slopeCali) in the following section [Graphical computation](#graphComp).\n\n<br>\n\n#### Overall metrics {-}\n\n<font size=\"4\"> **Time-dependent Brier score** </font> \n\nThe `R` package [**riskRegression**](https://CRAN.R-project.org/package=riskRegression) can assess the prediction error curves of survival models based on the time-dependent Brier score.\nSimilar to the time-dependent AUC, one needs to first calculate the linear predictors ($lp$) from a frequentist or Bayesian Cox model, and then use `survival::coxph()` to regress the survival outcomes on the linear predictor, which is prepared as input of `riskRegression::Score()` to estimate the (time-dependent) Brier score. \nIf the survival model was fitted via the `R` package [**psbcSpeedUp**](#psbcSpeedUp), the curve of the time-dependent Brier score can be drawn by using the function `psbcSpeedUp::plotBrier()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## time-dependent Brier score\n\n# use the (x_train, y_train) 80% samples for training\n# and the (x_validate, y_validate) 20% samples for testing\n\ny_train_surv <- Surv(y_train[, \"time\"], y_train[, \"status\"])\ny_validate_surv <- Surv(y_validate[, \"time\"], y_validate[, \"status\"])\nset.seed(123)\ncvfit <- cv.glmnet(x_train, y_train_surv, family = \"cox\", nfolds = 5, penalty.factor = pf)\nlp_train <- predict(cvfit, newx = x_train, s = cvfit$lambda.min, type = \"link\")\nlp_validate <- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n\n# prepare data format suited for function Score() from the riskRegression package\ndata_train <- data.frame(time = y_train[, \"time\"], status = y_train[, \"status\"], lp = as.vector(lp_train))\ndata_validate <- data.frame(time = y_validate[, \"time\"], status = y_validate[, \"status\"], lp = as.vector(lp_validate))\nlasso_train <- coxph(Surv(time, status) ~ lp, data = data_train, y = TRUE, x = TRUE)\nlasso_validate <- coxph(Surv(time, status) ~ lp, data = data_validate, y = TRUE, x = TRUE)\n\n# calculate Brier scores based on both training and validation data\nBrier_train <- riskRegression::Score(list(\"Brier_train\" = lasso_train), formula = Surv(time, status) ~ 1, data = data_train, conf.int = FALSE, metrics = \"brier\", summary = \"ibs\", times = sort(unique(data_train$time)))$Brier$score\nBrier_validate <- riskRegression::Score(list(\"Brier_validate\" = lasso_validate), formula = Surv(time, status) ~ 1, data = data_validate, conf.int = FALSE, metrics = \"brier\", summary = \"ibs\", times = sort(unique(data_validate$time)))$Brier$score\nBrier_score <- rbind(Brier_train, Brier_validate)\nBrier_score <- Brier_score[Brier_score$model != \"Null model\", ]\n\nggplot(Brier_score, aes(times, Brier, group = model, color = model)) +\n  xlab(\"Evaluation time points (year)\") +\n  ylab(\"Brier score\") +\n  geom_step(direction = \"vh\") +\n  theme(legend.position = c(0.15, 0.88), legend.title = element_blank())\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Time-dependent Brier score based on a Lasso Cox model applied to the BRCA patients data from TCGA. The red line shows the Time-dependent Brier score calculated from the 80% training data, and the green line shows the Time-dependent Brier score calculated from the 20% validation data._](fig/TCGA_surv_brier_t_lasso.png){width=60%}\n\n<br>\n\n<font size=\"4\"> **Integrated Brier score (IBS)** </font> \n\nThe function `riskRegression::Score()` also summarizes IBS when specifying argument `summary = \"ibs\"`.\nWe can extract the IBS corresponding to the largest evaluation time point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBrier_validate_ibs <- Brier_validate[Brier_validate$model == \"Brier_validate\", ]\nBrier_validate_ibs$IBS[which.max(Brier_validate_ibs$times)]\n```\n:::\n\n```{.border}\n[1] 0.1721158\n```\n\n<br>\n\n#### Uncertainty Quantification {-#uq1}\n\n:::{.callout-important}\n**It is recommended to use resampling-based methods** for estimating the uncertainty of the model's performance, if there are no **independent** validation data for model evaluation.\nThis can be done for example by repeatedly splitting the dataset to training/validation sets and evaluating a model's performance on the different validation sets using various discrimination or calibration metrics.\n:::\n\nWe demonstrate how to randomly split the data, e.g. $100$ times, train a Lasso Cox model and estimate the integrated AUC based on the validation data in each replication.\nFor other Cox-type models, we can just replace the model fitting part `cv.glmnet()` (and `predict()`) in the `for` loop below.\nHowever, most of the Bayesian Cox models introduced previously are computationally time-consuming when randomly splitting the data many times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# split the data 100 times\nset.seed(123)\nk <- 100\niAUC <- rep(NA, k)\nfor (i in 1:k) {\n  idx <- sample(1:n, n * 0.8, replace = FALSE)\n  x_train <- x[idx, ]\n  y_train <- y[idx, ]\n  x_validate <- x[-idx, ]\n  y_validate <- y[-idx, ]\n  cvfit <- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  pred_lp <- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n  utimes <- sort(unique(y_validate[y_validate[, 2] == 1, 1]))\n  AUC <- rep(NA, length(utimes))\n  for (j in 1:length(utimes)) {\n    out <- CoxWeights(marker = pred_lp, Stime = y_validate[, 1], status = y_validate[, 2], predict.time = utimes[j])\n    AUC[j] <- out$AUC\n  }\n  surv_prob <- unique(survfit(Surv(y_validate[, 1], y_validate[, 2]) ~ 1)$surv)\n  iAUC[i] <- IntegrateAUC(AUC, utimes, surv_prob, tmax = 10)\n}\ndat_tmp <- data.frame(x = \"Lasso Cox\", y = iAUC)\n\nset.seed(123)\nggplot(dat_tmp, aes(x, y)) +\n  geom_boxplot() +\n  ylim(0.5, 1) +\n  xlab(\"\") +\n  ylab(\"Integrated AUC\") +\n  geom_jitter(color = \"blue\", size = 0.5, alpha = 0.5)\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Integrated AUC based on randomly split validation data 100 times. The blue dots are the 100 values of integrated AUC._](fig/TCGA_surv_iauc_lasso.png){width=30%}\n\n<br>\n\nSimilar to obtaining uncertainty of the integrated AUC, we can also estimate the uncertainty of the C-index for evaluating the global performance of our model's discrimination.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# split the data 100 times\nset.seed(123)\nk <- 100\nCindex_all <- data.frame(Harrell = rep(NA, k), Uno = rep(NA, k))\nfor (i in 1:k) {\n  idx <- sample(1:n, n * 0.8, replace = FALSE)\n  x_train <- x[idx, ]\n  y_train <- y[idx, ]\n  x_validate <- x[-idx, ]\n  y_validate <- y[-idx, ]\n  cvfit <- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  pred <- predict(cvfit, newx = x_validate, type = \"response\", s = cvfit$lambda.min)\n  Cindex_all$Harrell[i] <- mean(apply(pred, 2, Cindex, y = y_validate))\n  Cindex_all$Uno[i] <- UnoC(y_train, y_validate, pred)\n}\ndat_tmp <- data.frame(x = rep(c(\"Harrell\", \"Uno\"), each = k), y = unlist(Cindex_all))\n\nset.seed(123)\nggplot(dat_tmp, aes(x, y, col = x)) +\n  geom_boxplot() +\n  geom_jitter(size = 0.5, alpha = 0.5) +\n  ylim(0, 1) +\n  xlab(\"\") +\n  ylab(\"C-index\") +\n  theme(legend.position = \"none\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_C-index (Harrell's and Uno's) based on randomly split validation data 100 times._](fig/TCGA_surv_cindex_lasso.png){width=40%}\n\n<br>\n\nThe `R` package [**c060**](https://CRAN.R-project.org/package=c060) [@Sill2014] includes wrapper functions for the [**glmnet**](https://CRAN.R-project.org/package=glmnet) algorithm and implements resampling-based methods (e.g. cross-validation and bootstrap - with and without replacement) based on the [**peperr**](https://CRAN.R-project.org/package=peperr) package to calculate the time-dependent Brier score.\n[**c060**](https://CRAN.R-project.org/package=c060) extends [**peperr**](https://CRAN.R-project.org/package=peperr) package to allow mandatory features without penalization.\n@Binder2008 recommends to draw bootstrap samples without replacement (i.e. subsampling), because bootstrap samples with replacement often result in too complex models in high-dimensional settings.\nTo use resampling by CV properly for survival data, see @Simon2011.\nNote that resampling-based methods here are similar to splitting $80\\%/20\\%$ the data many times which allows us to quantify the uncertainty of the time-dependent Brier score.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## time-dependent Brier score by subsampling from the whole data\nset.seed(123)\npeperr_object <- peperr::peperr(\n  response = y_surv, x = x, fit.fun = fit.glmnet,\n  args.fit = list(family = \"cox\", penalty.factor = pf),\n  complexity = complexity.glmnet,\n  args.complexity = list(family = \"cox\", nfolds = 5, penalty.factor = pf),\n  indices = resample.indices(n = n, method = \"sub632\", sample.n = 100)\n)\nc060::Plot.peperr.curves(peperr_object)\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Resampling-based prediction error curves (time-dependent Brier score) a the Lasso Cox model applied to the BRCA data set from TCGA. The gray area indicates the pointwise 2.5% and 97.5% quantiles of the 100 out-of-bag bootstrap samples. The other lines show the prediction error curves of the null model (estimated by the Kaplan-Meier estimator without covariate information), the full apparent error estimates (i.e., the errors as estimated when applying the model to the entire training data set), and the .632+ bootstrap error estimates._](fig/TCGA_surv_brier_lasso.png){width=50%}\n\n<br>\n\n#### Feature stability analysis {-}\n\nTo identify stable omics features, a straightforward way is to find the overlapped omics features with nonzero coefficients among different data subsets (e.g. CV folds or resamples).\nThe following code summarizes the Lasso Cox selected omics features which were identified at least $2$ or $5$ out of $10$ resamples.\nSimilarly, this approach can be applied to other Lasso-type or Bayesian Cox models that perform feature selection for identifying stable selected features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# specify the number of resamples k\nk <- 10\nbeta_all <- matrix(nrow = ncol(x), ncol = k)\nset.seed(123)\nfor (j in 1:k) {\n  resample_id <- sample(1:nrow(y), nrow(y), replace = TRUE)\n  resample_x <- x[resample_id, ]\n  resample_y <- y[resample_id, ]\n  cvfit <- cv.glmnet(resample_x, resample_y, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  beta_all[, j] <- as.vector(coef(cvfit, s = cvfit$lambda.min))\n}\n\n(stable_features <- colnames(x)[rowSums(beta_all != 0) >= 2])\n```\n:::\n\n```{.border}\n [1] \"age\"       \"ethnicity\" \"ANLN\"      \"UBE2T\"     \"NDC80\"     \"PGR\"       \"ORC6\"     \n [8] \"ESR1\"      \"PHGDH\"     \"MMP11\"     \"SFRP1\"     \"CCNE1\"     \"BLVRA\"     \"BAG1\"     \n[15] \"MLPH\"      \"CENPF\"     \"KRT17\"     \"FOXA1\"     \"ACTR3B\"    \"CCNB1\"     \"MDM2\"     \n[22] \"MYC\"       \"CEP55\"     \"SLC39A6\"   \"GRB7\"      \"NUF2\"      \"EGFR\"      \"MKI67\"    \n[29] \"TMEM45B\"   \"FGFR4\"     \"MELK\"      \"NAT1\"      \"CXXC5\"     \"BCL2\"      \"GPR160\"   \n[36] \"TYMS\"      \"KRT5\"      \"MAPT\"      \"MIA\"\n```\n\n::: {.cell}\n\n```{.r .cell-code}\n(stable_features <- colnames(x)[rowSums(beta_all != 0) >= 5])\n```\n:::\n\n```{.border}\n [1] \"age\"       \"ethnicity\" \"ANLN\"      \"ORC6\"      \"MMP11\"     \"BLVRA\"     \"BAG1\"     \n [8] \"CCNB1\"     \"EGFR\"      \"TMEM45B\"   \"BCL2\"      \"TYMS\"      \"KRT5\"      \"MIA\"\n```\n\nAlternatively for a Bayesian Cox model, its median probability model (MPM) can be obtained based on the coefficient estimates over MCMC iterations.\nThe following code shows how to obtain the MPM's coefficients of the penalized semiparametric Bayesian Cox model with Elastic Net prior run previously.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngammas <- colMeans(matrix(as.numeric(EN_beta_p != 0), ncol = ncol(EN_beta_p)))\nbeta_MPM <- (gammas >= 0.5) * colMeans(EN_beta_p) / gammas\nbeta_MPM[is.na(beta_MPM)] <- 0\nbeta_MPM\n```\n:::\n\n```{.border}\n          age     ethnicity          ANLN         FOXC1          CDH3         UBE2T \n 1.305162e-02  5.348458e-03 -1.299443e-03 -1.857811e-02 -6.123574e-03 -5.467111e-03 \n        NDC80           PGR         BIRC5          ORC6          ESR1         PHGDH \n-6.652927e-03 -2.101243e-06 -1.640386e-02 -1.237153e-02 -1.077863e-02  2.483990e-02 \n         CDC6         MMP11         MYBL2         SFRP1         CCNE1         BLVRA \n-9.079708e-03 -1.588726e-02  5.225344e-03 -1.383981e-02 -3.181265e-03 -2.632373e-02 \n         BAG1          MLPH         CDC20         CENPF         KRT17         FOXA1 \n-3.913529e-02 -1.435805e-02 -2.027232e-02 -2.476495e-02 -2.871143e-02 -3.017213e-03 \n       ACTR3B         CCNB1          MDM2           MYC         CEP55       SLC39A6 \n-2.504869e-03 -1.346817e-03 -2.156041e-02  1.431062e-02  1.421036e-02 -1.150196e-02 \n        ERBB2          GRB7         KIF2C          NUF2          EGFR         MKI67 \n-6.347367e-03 -1.008689e-02  6.033792e-03 -2.405689e-03 -1.964927e-02  1.956661e-02 \n      TMEM45B         FGFR4         PTTG1          MELK          NAT1         CXXC5 \n 2.736216e-02  1.842323e-03 -5.651905e-03  2.894074e-02 -2.126163e-02  2.571472e-02 \n         BCL2          RRM2        GPR160          EXO1         UBE2C          TYMS \n-5.140894e-03  2.881004e-02 -3.927705e-02 -1.710419e-02 -1.343832e-02 -1.884342e-02 \n         KRT5         KRT14          MAPT           MIA \n-2.180294e-02 -1.386489e-03 -2.587557e-02 -1.033317e-02\n```\n\n<br>\n\n#### Graphical representation {-#graphComp}\n\nAfter identifying stable omics features predictive of survival outcomes, we can draw a **nomogram** to allows the graphical calculation of survival probabilities and report a **calibration plot** for practitioners.\n\n<font size=\"4\"> **Nomogram** </font> \n\nWe demonstrate a nomogram using the stable selected features from TCGA breast cancer data preprocessed previously.\nThe `R` package **regplot** draws an enhanced regression nomogram based on the **rms** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove patients without reporting ethnicity\nyy <- y[x[, 2] != 3, ]\nxx <- x[x[, 2] != 3, ]\n# specify the number of resamples k\nk <- 10\nbeta_all <- matrix(nrow = ncol(xx), ncol = k)\nset.seed(123)\nfor (j in 1:k) {\n  resample_id <- sample(1:nrow(yy), nrow(yy), replace = TRUE)\n  resample_x <- xx[resample_id, ]\n  resample_y <- yy[resample_id, ]\n  cvfit <- cv.glmnet(resample_x, resample_y, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  beta_all[, j] <- as.vector(coef(cvfit, s = cvfit$lambda.min))\n}\n\n# identify features at least 80% frequently selected\nx_stable <- data.frame(xx[, rowSums(beta_all != 0) >= k * 0.8])\nx_stable$ethnicity <- factor(x_stable$ethnicity)\nlevels(x_stable$ethnicity) <- c(\"Hispanic/latino\", \"Not hispanic/latino\")\n\ndata_tmp <- data.frame(times = yy[, \"time\"], status = yy[, \"status\"], x_stable)\nf <- cph(\n  formula = Surv(times, status) ~ age + ethnicity + ANLN + BLVRA + EGFR,\n  data = data_tmp, x = TRUE, y = TRUE, surv = TRUE\n)\nddist <- datadist(data_tmp)\noldoption <- options(datadist = \"ddist\")\nsurv <- Survival(f)\nnom <- nomogram(f,\n  fun = list(function(x) surv(1, x), function(x) surv(3, x), function(x) surv(5, x)),\n  funlabel = c(\n    \"1-Year Survival Probability\",\n    \"3-Year Survival Probability\",\n    \"5-Year Survival Probability\"\n  ),\n  lp = FALSE\n)\nregplot::regplot(f,\n  observation = data_tmp[1, ], failtime = c(1, 3, 5), title = \"\",\n  prfail = FALSE, points = TRUE, showP = FALSE, subticks = TRUE\n)\n```\n:::\n\n![_Nomogram developed to estimate the overall survival probability for TCGA's BRAC patients based on demographic and Lasso Cox selected mRNA features. The red coloured symbols represent one patient’s information and predicted probabilities of 1-year, 3-year and 5-year survival._](fig/TCGA_surv_nomogram.png){width=80%}\n\n<br> \n\n<font size=\"4\"> [**Calibration plot**]{#slopeCali} </font> \n\nA calibration plot is a straightforward visualization to show the prediction ability of the nomogram, i.e., the agreement between predicted survival probabilities from the final model and the KM estimated survival probabilities in different percentiles of the predicted values at a time point of interest. \nWe demonstrate below calibration plots based on training and validation data sets, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calibration at 5-year time-point\n\n# prepare suitable data format for calibration plot\nset.seed(123)\ntrain_id <- sample(1:nrow(yy), nrow(yy) * 0.8, replace = FALSE)\ndata_train <- data_tmp[train_id, ]\ndata_validate <- data_tmp[-train_id, ]\n\nddist <- datadist(data_train)\noptions(datadist = \"ddist\")\nf_train <- cph(\n  formula = Surv(times, status) ~ age + ethnicity + ANLN + BLVRA + EGFR,\n  data = data_train, x = TRUE, y = TRUE, surv = TRUE, time.inc = 5\n)\nf_validate <- update(f_train, data = data_validate)\ncal_train <- calibrate(f_train, u = 5, cmethod = \"KM\", m = nrow(data_train) / 4, B = 200)\ncal_validate <- calibrate(f_validate, u = 5, cmethod = \"KM\", m = nrow(data_validate) / 4, B = 200)\n\nlayout(matrix(1:2, nrow = 1))\nplot(cal_train,\n  lwd = 2, lty = 1, errbar.col = \"seagreen3\",\n  xlab = \"Predicted survival probability\", ylab = \"Actual survival probability\",\n  xlim = c(0, 1), ylim = c(0, 1), col = \"seagreen3\", subtitles = FALSE\n)\ntitle(main = \"Calibration on training data\")\n\nplot(cal_validate,\n  lwd = 2, lty = 1, errbar.col = \"seagreen3\",\n  xlab = \"Predicted survival probability\", ylab = \"Actual survival probability\",\n  xlim = c(0, 1), ylim = c(0, 1), col = \"seagreen3\", subtitles = FALSE\n)\ntitle(main = \"Calibration on validation data\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Nomogram model calibration curves for TCGA's BRAC patients at 5-year evaluation time-point._](fig/TCGA_surv_calibration.png){width=70%}\n\n<br>\n\n### Model evaluation (mlr3) {-#mlr3}\n\n:::{.callout-tip}\n## We will use the [**mlr3**](https://mlr3.mlr-org.com) ML framework and the [**mlr3proba**](https://mlr3proba.mlr-org.com) `R` library to:\n\n- Create a survival task from a dataset and split it to training and test (validation) sets\n- Define a Lasso Cox model that can output both linear predictors and survival distribution predictions and train/tune it on the training set\n- Make predictions using the trained Lasso Cox model on the separate test set\n- Measure the performance of our model (discrimination and calibration) using several evaluation metrics\n- Using resampling techniques, we will assess our model's capacity for generalization (prediction on unseen data) and the stability of the model's selected features\n:::\n\nFor the rest of the analysis, we will borrow the terminology from the [**mlr3**](https://mlr3.mlr-org.com) ecosystem of machine learning packages (e.g. *task* is a dataset, *learner* is a model, etc.).\nSee [mlr3 book](https://mlr3book.mlr-org.com/) for more details.\n\nFirst, we load the necessary [**mlr3**](https://mlr3.mlr-org.com) libraries [@Lang2019; @Sonabend2021] and some other useful ones:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"mlr3verse\") # mlr3, mlr3pipeplines, mlr3learners, mlr3tuning, paradox, etc.\nlibrary(\"mlr3proba\") # probabilistic learning and survival analysis\nlibrary(\"mlr3extralearners\") # for lrn('surv.glmnet')\n```\n:::\n\n\n<br>\n\n#### Workflow {-}\n\nWe construct an [**mlr3**](https://mlr3.mlr-org.com) *survival task* (TCGA BRCA dataset essentially, with normalized PAM50 gene expression features and two clinical/demographic variables) and split it into training and test sets ($80\\%/20\\%$):\n\n::: {.cell}\n\n```{.r .cell-code}\n# From 'Penalized Cox models' section:\n# x => gene expression matrix (50 PAM50 genes) + 2 clinical variables\n# y => (time, status) target matrix\n\ndata <- cbind.data.frame(x, y)\n# data = readRDS(file = 'data.rds')\ntask <- mlr3proba::as_task_surv(\n  x = data,\n  time = \"time\", event = \"status\", id = \"BRCA-TCGA\"\n)\ntask # see useful info about the dataset (#features, #samples, target variables)\n\n# split to train and test sets\nset.seed(42)\nsplit <- mlr3::partition(task, ratio = 0.8)\n# split$train # train indices\n# split$test # test indices\n```\n:::\n\n```{.border}\n<TaskSurv:BRCA-TCGA> (1047 x 54)\n* Target: time, status\n* Properties: -\n* Features (52):\n  - dbl (52): ACTR3B, ANLN, BAG1, BCL2, BIRC5, BLVRA, CCNB1, CCNE1, CDC20, CDC6, CDH3,\n    CENPF, CEP55, CXXC5, EGFR, ERBB2, ESR1, EXO1, FGFR4, FOXA1, FOXC1, GPR160, GRB7,\n    KIF2C, KRT14, KRT17, KRT5, MAPT, MDM2, MELK, MIA, MKI67, MLPH, MMP11, MYBL2, MYC,\n    NAT1, NDC80, NUF2, ORC6, PGR, PHGDH, PTTG1, RRM2, SFRP1, SLC39A6, TMEM45B, TYMS,\n    UBE2C, UBE2T, age, ethnicity\n```\n\nWe create a Lasso Cox [**mlr3**](https://mlr3.mlr-org.com) learner (a wrapper around the `glmnet::cv.glmnet()` function with the capacity to provide survival predictions), where we specify the two clinical variables to be *mandatory* (i.e. no penalization) and the $s$ value ($\\lambda$ parameter used for prediction) equal to `lambda.min`:\n\n::: {.cell}\n\n```{.r .cell-code}\n# tail(task$feature_names) # age, ethnicity are the 2 last features\npf <- c(rep(1, length(task$feature_names) - 2), rep(0, 2))\n\n# define model\ncoxlasso <- lrn(\"surv.cv_glmnet\",\n  alpha = 1, nfolds = 5, s = \"lambda.min\",\n  penalty.factor = pf\n)\n# coxlasso # see learner details\n# coxlasso$help() # see learner documentation\n```\n:::\n\n\n:::{.callout-note}\nA Cox proportional hazards model (and Lasso Cox as a consequence) is a semi-parametric model, which means that it does not produce survival distribution predictions by default.\nThe mlr3 `glmnet` survival learner uses internally the function `glmnet::survfit.coxnet()` to transform the `cv.glmnet`'s linear predictors (`lp`) to survival distribution predictions.\nThis transformation uses the **Breslow estimator** for the cumulative baseline hazard (see `stype` parameter in `survival::survfit.coxph()`).\n:::\n\n<br>\n\nTrain the Lasso Cox model:\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(3)\ncoxlasso$train(task, row_ids = split$train)\n# view `cv.glmnet` fit\ncoxlasso$model$model\n```\n:::\n\n```{.border}\nCall:  (if (cv) glmnet::cv.glmnet else glmnet::glmnet)(x = data, y = target,      nfolds = 5L, alpha = 1, penalty.factor = c(1, 1,..., 1, 0, 0), family = \"cox\")\n\nMeasure: Partial Likelihood Deviance \n\n     Lambda Index Measure     SE Nonzero\nmin 0.01082    14   12.31 0.2743      15\n1se 0.03626     1   12.35 0.2564       2\n```\n\nGet the survival distribution predictions ($distr$) along with the linear predictors ($lp$):\n\n::: {.cell}\n\n```{.r .cell-code}\npred <- coxlasso$predict(task, row_ids = split$test)\nhead(as.data.table(pred))\n```\n:::\n\n```{.border}\n   row_ids      time status     crank        lp     distr\n1:       5 0.9527721  FALSE -2.346574 -2.346574 <list[1]>\n2:       6 4.0438056  FALSE -2.806708 -2.806708 <list[1]>\n3:      15 1.7385352  FALSE -1.845042 -1.845042 <list[1]>\n4:      45 4.5804244  FALSE -1.715041 -1.715041 <list[1]>\n5:      50 5.1279945  FALSE -2.790122 -2.790122 <list[1]>\n6:      54 6.6858316  FALSE -2.466360 -2.466360 <list[1]>\n```\n\nSo for every patient in the test set, the Lasso Cox model prediction is a linear predictor of the form $lp = \\hat{\\beta} X_{new}$.\n$crank$ stands for continuous ranking score and it's the same as $lp$ for the Lasso Cox model.\nThe $distr$ predictions are the per-patient survival distribution predictions, implemented by the `R` package [distr6](https://github.com/alan-turing-institute/distr6) which the [**mlr3proba**](https://mlr3proba.mlr-org.com) imports.\nSee respective [documentation](https://mlr3proba.mlr-org.com/reference/PredictionSurv.html) on the different prediction types supported.\n\nAn example of using the `distr` predictions would be to request for the survival probability at e.g. $1,5,10,20$ years for the first two patients in the test set:\n\n::: {.cell}\n\n```{.r .cell-code}\ntimes <- c(1, 5, 10, 20)\nids <- c(1,2)\npred$distr[ids]$survival(times)\n\n# same logic for the cumulative hazard\n# pred$distr[ids]$cumHazard(times)\n```\n:::\n\n```{.border}\n        [,1]      [,2]\n1  0.9889822 0.9930314\n5  0.8711262 0.9165987\n10 0.6708848 0.7772850\n20 0.4540815 0.6075516\n```\n\n<br>\n\n#### Discrimination metrics {-}\n\nWe want to test our Lasso Cox model and see how well it was able to **discriminate the patients in the test set**.\nFor this we can use the $lp$ predictions of Lasso Cox model and metrics such as the (time-dependent) C-index and (time-dependent) AUC.\n<br>\n\n<font size=\"4\"> **Harrell's C-index** [@Harrell1982]: </font> \n\n::: {.cell}\n\n```{.r .cell-code}\nharrell_c <- msr(\"surv.cindex\")\nharrell_c$id <- \"surv.cindex.harrell\"\n\n# harrell_c # get some details about the measure\n# harrell_c$minimize # FALSE => higher C-index is better\n# harrell_c$range # [0, 1] => [min, max]\n# harrell_c$predict_type # uses the $crank$ predictions (equal to $lp$ for Lasso Cox\n\npred$score(harrell_c)\n```\n:::\n\n```{.border}\nsurv.cindex.harrell \n          0.6224306\n```\n\n<br>\n\n<font size=\"4\"> **Uno's C-index** [@Uno2011]: (across all time points of the test set): </font> \n\n::: {.cell}\n\n```{.r .cell-code}\nuno_c <- msr(\"surv.cindex\", weight_meth = \"G2\")\nuno_c$id <- \"surv.cindex.uno\"\n\n# Uno's C needs the train data\npred$score(uno_c, task = task, train_set = split$train)\n```\n:::\n\n```{.border}\nsurv.cindex.uno \n      0.5932426\n```\n\n<br>\n\n<font size=\"4\"> **Uno's Integrated AUC** [@Uno2007] (across all time points of the test set): </font> \n\n::: {.cell}\n\n```{.r .cell-code}\nuno_iauc <- msr(\"surv.uno_auc\")\nuno_iauc$id <- \"surv.uno_iauc\"\n# uno_iauc$param_set$values$integrated # integrated = TRUE by default\n# sort(unique(pred$truth[,1])) # time points used\n\n# uno_iauc$properties # needs the train data\npred$score(uno_iauc, task = task, train_set = split$train)\n```\n:::\n\n```{.border}\nsurv.uno_iauc \n    0.6585791\n```\n\n<br>\n\n<font size=\"4\"> **Uno's AUC at a specific time point**, e.g. $10$ years: </font> \n\n::: {.cell}\n\n```{.r .cell-code}\nuno_auc <- msr(\"surv.uno_auc\", integrated = FALSE, times = 10)\nuno_auc$id <- \"surv.uno_auc.10\"\n\n# needs the train data\npred$score(uno_auc, task = task, train_set = split$train)\n```\n:::\n\n```{.border}\nsurv.uno_auc.10 \n      0.667014\n```\n\n<br>\n\n#### Calibration metrics {-}\n\nWe want to test how well our Lasso Cox model was **calibrated**. @Andres2018 and @Haider2020 suggested the distributional (D)-calibration accounting survival probabilities across all times. This can be useful when assessing the entire post-treatment survival prognosis, for example, assessing the post liver transplantation survival utility in @Andres2018.\n\n<font size=\"4\"> **D-calibration** </font> \n\n::: {.cell}\n\n```{.r .cell-code}\ndcal <- msr(\"surv.dcalib\")\npred$score(dcal)\n```\n:::\n\n```{.border}\nsurv.dcalib\n   0.8342449\n```\n\n<br>\n\n#### Overall metrics {-}\n\nUsually we derive an estimation of the error between the survival distributions ($distr$ predictions) of the patients in the test set and their actual survival outcomes (corresponding to the survival task's `time` and `status` variables).\nThe most frequently used metric is the Brier Score [@Graf1999]:\n<br>\n\n<font size=\"4\"> **Integrated Brier Score (IBS)** (across all time points of the test set): </font> \n\n::: {.cell}\n\n```{.r .cell-code}\nibrier <- msr(\"surv.brier\", proper = TRUE)\n# ibrier$help() # see documentation\n# ibrier$predict_type # uses the `distr` predictions\n\n# better to use the train data for the Kaplan-Meier estimation of the censoring distribution, but can use the test set as well\npred$score(ibrier, task = task, train_set = split$train)\n```\n:::\n\n```{.border}\nsurv.graf \n0.1157316\n```\n\nWe can also get the *standard error* of IBS (the above result is the mean across all the test set's patients) as follows:\n\n::: {.cell}\n\n```{.r .cell-code}\nibrier_se <- msr(\"surv.brier\", proper = TRUE, se = TRUE)\npred$score(ibrier_se, task = task, train_set = split$train)\n```\n:::\n\n```{.border}\n surv.graf \n0.01795861\n```\n\n<br>\n\n<font size=\"4\"> **Brier Score at a specific time point**, e.g. $10$ years: </font> \n\n::: {.cell}\n\n```{.r .cell-code}\nbrier10 <- msr(\"surv.brier\", proper = TRUE, integrated = FALSE, times = 10)\nbrier10$id <- \"surv.graf.10\"\n\n# better to use the train data for the Kaplan-Meier estimation of the censoring distribution, but can use the test set as well\npred$score(brier10, task = task, train_set = split$train)\n```\n:::\n\n```{.border}\nsurv.graf.10 \n   0.1755639\n```\n\n<br>\n\n<font size=\"4\"> **Right-censored Logarithmic Loss score** (RCLL) [@Avati2020;@Sonabend2022]: </font> \n\n::: {.cell}\n\n```{.r .cell-code}\nrcll <- msr(\"surv.rcll\")\npred$score(rcll)\n```\n:::\n\n```{.border}\nsurv.rcll \n 4.781513\n```\n\n<br>\n\n:::{.callout-note}\nView all evaluation metrics for survival data implemented in [**mlr3proba**](https://mlr3proba.mlr-org.com) [here](https://mlr3proba.mlr-org.com/reference/#survival-measures)\n:::\n\n<br>\n\n#### Uncertainty Quantification {-}\n\nSimilar procedure as followed in a [previous section](#uq1).\n\nWe will perform a **stratified split** of the BRCA-TCGA survival task to training and test sets (with a $80\\%/20\\%$ ratio as before).\nStratification on the censoring indicator `status` is important because we want our training and test sets to have the same censoring distribution as the initial dataset.\nThus we can avoid measuring performance on test sets with severely different censoring distributions that might influence the performance scores.\n\nStratify survival task by `status`:\n\n::: {.cell}\n\n```{.r .cell-code}\ncoxlasso$reset() # un-train model\n\ntask$col_roles$stratum <- \"status\"\n# task\n```\n:::\n\n\nNext, we define the type of resampling (`?mlr_resamplings_subsampling`), train the Lasso Cox model on all training sets ($100$) and store the fitted models for feature selection and evaluation:\n\n::: {.cell}\n\n```{.r .cell-code}\n# 100 times train/test split (80% for training, 20% for validation)\nsubsampling <- rsmp(\"subsampling\", repeats = 100, ratio = 0.8)\n\nset.seed(42)\nrr <- mlr3::resample(\n  task = task, learner = coxlasso,\n  resampling = subsampling, store_models = TRUE, store_backends = TRUE\n)\n```\n:::\n\n\nWe can use all the aforementioned evaluation metrics to measure the performance of the Lasso Cox models on the $100$ different test sets.\nNote that if a metric needs the training dataset it is automatically provided by the `ResampleResult` object (`rr`):\n\n::: {.cell}\n\n```{.r .cell-code}\nmeasures <- list(harrell_c, uno_c, uno_iauc, uno_auc, ibrier, brier10, rcll, dcal)\n\nres <- rr$score(measures = measures)\nhead(res)\n```\n:::\n\n```{.border}\n    task_id learner_id resampling_id iteration surv.cindex.harrell surv.cindex.uno \n1: BRCA-TCGA  Lasso Cox   subsampling         1           0.5679167       0.6090304\n2: BRCA-TCGA  Lasso Cox   subsampling         2           0.5422131       0.4884603\n3: BRCA-TCGA  Lasso Cox   subsampling         3           0.7604049       0.5740556\n4: BRCA-TCGA  Lasso Cox   subsampling         4           0.6610169       0.5277736\n5: BRCA-TCGA  Lasso Cox   subsampling         5           0.5800073       0.5655076\n6: BRCA-TCGA  Lasso Cox   subsampling         6           0.5427837       0.6975740\n  surv.uno_iauc surv.uno_auc.10 surv.graf surv.graf.10 surv.rcll surv.dcalib\n1:     0.6628350       0.4719335 0.1736450    0.2582078  4.914347   0.5890987\n2:     0.4023684       0.5652588 0.1855191    0.2185453  4.914264   0.6552037\n3:     0.5941948       0.5235439 0.1014616    0.1329289  5.041827   0.8480314\n4:     0.5360690       0.5110032 0.1122070    0.1157937  5.045144   0.4981035\n5:     0.6160743       0.5388393 0.1099091    0.1940644  5.060352   0.2036418\n6:     0.6494779       0.6400328 0.1377626    0.2445218  5.059521   0.5175357\nHidden columns: task, learner, resampling, prediction\n```\nWe extract and visualize the discrimination and calibration (resampled) performance of our Lasso Cox model using several evaluation metrics:\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\n# C-indexes, AUCs (integrated and at t = 10 years)\nres[, .(surv.cindex.harrell, surv.cindex.uno, surv.uno_iauc, surv.uno_auc.10)] %>%\n  tidyr::pivot_longer(\n    cols = tidyselect::everything(),\n    names_to = \"Measure\", values_to = \"Value\"\n  ) %>%\n  mutate(Measure = case_when(\n    Measure == \"surv.cindex.harrell\" ~ \"Harrell's C-index\",\n    Measure == \"surv.cindex.uno\" ~ \"Uno's C-index\",\n    Measure == \"surv.uno_iauc\" ~ \"Uno's Integrated AUC\",\n    Measure == \"surv.uno_auc.10\" ~ \"Uno's AUC (t = 10 years)\",\n  )) %>%\n  mutate(Measure = factor(Measure, levels = c(\n    \"Harrell's C-index\",\n    \"Uno's C-index\",\n    \"Uno's Integrated AUC\",\n    \"Uno's AUC (t = 10 years)\"\n  ))) %>%\n  ggplot(aes(x = Measure, y = Value, fill = Measure)) +\n  geom_boxplot() +\n  ylim(c(0.2, 0.8)) +\n  geom_hline(yintercept = 0.5, color = \"red\", linetype = \"dashed\") +\n  theme_bw(base_size = 14) +\n  labs(title = \"Discrimination Measures\") +\n  theme(axis.text.x = element_blank())\n```\n:::\n\n::: {.cell}\n\n:::\n\n![_Discrimination performance of Lasso Cox on the TCGA-BRCA dataset (expression data of the PAM50 genes and the variables age and ethnicity). Performance metrics used are Harrell's C-index, Uno's C-index, Uno's Integrated AUC and Uno's AUC at 10 years. The dataset was split to training/validation sets 100 times to allow for the quantification of uncertainty in the different performance estimates._](fig/mlr3_discrimination_msrs.png){width=70%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# different scales for each measure, so we separate the plots\nset.seed(42)\n\n# Integrated Brier Score and Brier Score at t = 10 years\nres[, .(surv.graf, surv.graf.10)] %>%\n  tidyr::pivot_longer(\n    cols = tidyselect::everything(),\n    names_to = \"Measure\", values_to = \"Value\"\n  ) %>%\n  mutate(Measure = case_when(\n    Measure == \"surv.graf\" ~ \"IBS\",\n    Measure == \"surv.graf.10\" ~ \"BS(t=10)\"\n  )) %>%\n  ggplot(aes(x = Measure, y = Value, fill = Measure)) +\n  geom_boxplot(show.legend = FALSE) +\n  geom_jitter(color = \"blue\", size = 0.5, alpha = 0.5, show.legend = FALSE) +\n  labs(title = \"Integrated Brier Score vs Brier Score (t = 10 years)\") +\n  theme_bw(base_size = 14) +\n  theme(axis.title.x = element_blank())\n\n# RCLL\nres[, .(surv.rcll)] %>%\n  tidyr::pivot_longer(\n    cols = tidyselect::everything(),\n    names_to = \"Measure\", values_to = \"Value\"\n  ) %>%\n  mutate(Measure = case_when(\n    Measure == \"surv.rcll\" ~ \"RCLL\"\n  )) %>%\n  ggplot(aes(x = Measure, y = Value)) +\n  geom_boxplot(show.legend = FALSE) +\n  geom_jitter(color = \"blue\", size = 0.5, alpha = 0.5, show.legend = FALSE) +\n  labs(title = \"Right-censored Log Loss\") +\n  theme_bw(base_size = 14) +\n  theme(axis.title.x = element_blank())\n```\n:::\n\n::: {.cell}\n\n:::\n\n<p align=\"left\">\n  <img alt=\"1\" src=\"./fig/mlr3_calibration_BS.png\" width=\"49%\">\n  <img alt=\"2\" src=\"./fig/mlr3_calibration_RCLL.png\" width=\"49%\">\n  <i>Calibration performance of Lasso Cox on the TCGA-BRCA dataset (expression data of the PAM50 genes and the variables age and ethnicity). Performance metrics used are the Integrated Brier Score (IBS), the Brier Score at 10 years and the Right-Censored Logarithmic Loss (RCLL). The dataset was split to training/validation sets 100 times to allow for the quantification of uncertainty in the different performance estimates.</i>\n</p>\n\n#### Feature stability analysis {-}\n\nWe can extract the selected features from all $100$ trained Lasso Cox models and create a frequency selection table:\n\n::: {.cell}\n\n```{.r .cell-code}\n# get selected features from all trained learners in a list\nsf_list <- lapply(rr$learners, function(learner) {\n  learner$selected_features()\n})\n\n# make frequency selection table\nn <- length(sf_list)\nfs_res <- sort(table(unlist(sf_list)), decreasing = TRUE)\ntimes <- as.vector(unname(fs_res))\ntibble::tibble(feat_name = names(fs_res), times = times, freq = times / n)\n```\n:::\n\n```{.border}\n# A tibble: 35 × 3\n   feat_name times  freq\n   <chr>     <int> <dbl>\n1 age         100  1\n2 ethnicity   100  1\n3 ANLN         43  0.43\n4 BLVRA        41  0.41\n5 BAG1         37  0.37\n6 MIA          34  0.34\n7 TYMS         30  0.3\n8 KRT5         27  0.27\n9 MMP11        27  0.27\n10 BCL2         26  0.26\n# ℹ 25 more rows\n```\n\nAs `age` and `ethnicity` were not penalized, they have non-zero coefficients in all Lasso Cox models and therefore are included in all selected feature sets.\n\nLastly, we can use the `R` package [**stabm**](https://CRAN.R-project.org/package=stabm) [@stabm] to assess how similar the $100$ selected feature sets were.\nWe will demonstrate the use of three metrics which measure the *stability* of the Lasso Cox's feature selection on the TCGA-BRCA dataset:\n\n1. The Jaccard index\n2. Nogueira's metric (corrected for chance, i.e. independent of the number of features; @Nogueira2018)\n3. Zucknick's metric (extension of Jaccard index that considers the correlation between the features; @Zucknick2008):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\njac <- stabm::stabilityJaccard(features = sf_list, correction.for.chance = \"none\")\nnog <- stabm::stabilityNogueira(features = sf_list, p = length(task$feature_names))\n\n# Similarity of each pair of features using Pearson correlation\nsim.mat <- abs(stats::cor(x = task$data(cols = task$feature_names), method = \"p\"))\nzuck <- stabm::stabilityZucknick(\n  features = sf_list, sim.mat = sim.mat,\n  threshold = 0.9, correction.for.chance = \"estimate\", N = 100\n)\n\ntibble::tibble(jaccard = jac, nogueira = nog, zucknick = zuck)\n```\n:::\n\n```{.border}\n# A tibble: 1 × 3\n  jaccard nogueira zucknick\n    <dbl>    <dbl>    <dbl>\n1   0.474    0.412    0.442\n```\n\nFrom the above values we conclude that the stability of Lasso Cox's feature selection is neither poor nor excellent but somewhere in between.\n\n# Multi-omics integrative modeling {-}\n\nIntegration of multi-omics data from various types of omics profiling technologies can improve our understanding of complex disease mechanisms holistically, and hence improve prediction of disease progression and survival [@Hasin2017;@Subramanian2020;@Vandereyken2023]. \nOne obvious benefit of multi-omics data is the availability of biological information from multiple, partly redundant levels, i.e., different modalities, which allows for the assessment of associations within and between different omics datasets. \n\nA naive strategy for multi-omics data analysis is to treat all the omics features equally and independently, which may lead to a worse performance in comparison to methods that take into account the group structure. \nA recent large-scale benchmarking study for survival prediction using TCGA multi-omics data demonstrated a slightly improved survival prediction performance when taking into account the group structure of the multi-omics data sets [@Herrmann2021]. \nHowever, @Herrmann2021 did not evaluate the survival model performance in terms of feature selection, i.e., selection of the most prognostic omics variables or features. \nTo capture associations within modalities of omics features, penalized regressions with a $\\ell_2$-norm penalty or Bayesian methods with a group lasso prior can become useful. \nFocusing on feature selection or parsimonious effects is often beneficial for the purpose of clinical implementation, where one can use the sparse Group-Lasso Cox [@Simon2013] and Bayesian Cox with elastic priors [@Lee2015]. \n\nTo capture associations between modalities of omics features, including their overlapping or nested and hierarchical relationships, the use of biological network structures can become useful, as for example in the Bayesian Cox model with spike-and-slab and MRF priors [@Madjar2021]. \nThere is an increasing knowledge of biological interconnections across various molecular profiles, and systems biology approaches are being developed that try to capture these deep insights when modeling or predicting disease mechanisms [@Yan2018;@Karimi2022]. \nThere is a number of review and benchmarking studies of the  methodologies for multi-omics integration, although these reviews do not focus specifically on survival applications; for example, @Herrmann2021 for penalized regression-based methods, boosting-based methods and random forest-based methods; @Agamah2022 for network analyses, @Ickstadt2018 and @Chu2022 for Bayesian approaches; and @Kang2022 for deep learning methods. \n\nHowever, to achieve a comprehensive and biologically meaningful integration of high-dimensional multi-omics data, there is a need for continued development of computational and statistical approaches that consider both technical and biological intricacies of the data and technologies, respectively [@Wissel2023]. \nThis is currently a very active research field, and we expect to see many improved multi-omics methods for survival prediction in the future.\n\n# R session info {.unlisted .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n:::\n\n```{.border}\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.7\n\nMatrix products: default\nBLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Oslo\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] stabm_1.2.2                 mlr3extralearners_0.7.1-9000     mlr3proba_0.5.3            \n [4] mlr3verse_0.2.8             mlr3_0.16.1                 regplot_1.1                \n [7] survAUC_1.2-0               rms_6.7-0                   Hmisc_5.1-0                \n[10] c060_0.3-0                  peperr_1.5                  snowfall_1.84-6.2          \n[13] snow_0.4-4                  riskRegression_2023.03.22   risksetROC_1.0.4.1         \n[16] MASS_7.3-60                 BhGLM_1.1.0                 GGally_2.1.2               \n[19] psbcGroup_1.5               mvtnorm_1.2-2               SuppDists_1.1-9.7          \n[22] LearnBayes_2.15.1           SGL_1.3                     grpreg_3.4.0               \n[25] plotmo_3.6.2                TeachingDemos_2.12          plotrix_3.8-2              \n[28] Formula_1.2-5               glmnet_4.1-7                Matrix_1.5-4.1             \n[31] M3C_1.22.0                  survminer_0.4.9             ggpubr_0.6.0               \n[34] survival_3.5-5              ggplot2_3.4.2               dplyr_1.1.2                \n[37] DESeq2_1.40.2               SummarizedExperiment_1.30.2 Biobase_2.60.0             \n[40] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1         IRanges_2.34.1             \n[43] S4Vectors_0.38.1            BiocGenerics_0.46.0         MatrixGenerics_1.12.2      \n[46] matrixStats_1.0.0           TCGAbiolinks_2.29.6        \n\nloaded via a namespace (and not attached):\n  [1] tgp_2.4-21                  progress_1.2.2              mlr3hyperband_0.4.5        \n  [4] penalized_0.9-52            nnet_7.3-19                 Biostrings_2.68.1          \n  [7] TH.data_1.1-2               vctrs_0.6.3                 digest_0.6.32              \n [10] png_0.1-8                   corpcor_1.6.10              shape_1.4.6                \n [13] proxy_0.4-27                parallelly_1.36.0           reshape_0.8.9              \n [16] foreach_1.5.2               withr_2.5.0                 param6_0.2.4               \n [19] xfun_0.39                   memoise_2.0.1               diptest_0.76-0             \n [22] MatrixModels_0.5-1          zoo_1.8-12                  DEoptimR_1.1-1             \n [25] distr6_1.8.0                prettyunits_1.1.1           prabclus_2.3-2             \n [28] KEGGREST_1.40.0             httr_1.4.6                  downloader_0.4             \n [31] maptree_1.4-8               rstatix_0.7.2               globals_0.16.2             \n [34] fpc_2.2-10                  rstudioapi_0.14             generics_0.1.3             \n [37] base64enc_0.1-3             curl_5.0.1                  zlibbioc_1.46.0            \n [40] doSNOW_1.0.20               GenomeInfoDbData_1.2.10     lgr_0.4.4                  \n [43] xtable_1.8-4                stringr_1.5.0               doParallel_1.0.17          \n [46] evaluate_0.21               S4Arrays_1.0.4              BiocFileCache_2.8.0        \n [49] hms_1.1.3                   colorspace_2.1-0            filelock_1.0.2             \n [52] cmprsk_2.2-11               reticulate_1.30             flexmix_2.3-19             \n [55] magrittr_2.0.3              readr_2.1.4                 modeltools_0.2-23          \n [58] lattice_0.21-8              palmerpenguins_0.1.1        future.apply_1.11.0        \n [61] robustbase_0.99-0           SparseM_1.81                XML_3.99-0.14              \n [64] class_7.3-22                pillar_1.9.0                nlme_3.1-162               \n [67] iterators_1.0.14            compiler_4.3.1              RSpectra_0.16-1            \n [70] stringi_1.7.12              paradox_0.11.1              minqa_1.2.5                \n [73] dictionar6_0.1.3            plyr_1.8.8                  crayon_1.5.2               \n [76] abind_1.4-5                 sm_2.2-5.7.1                locfit_1.5-9.8             \n [79] bit_4.0.5                   sandwich_3.0-2              mlr3mbo_0.2.1              \n [82] codetools_0.2-19            multcomp_1.4-25             matrixcalc_1.0-6           \n [85] openssl_2.0.6               e1071_1.7-13                splines_4.3.1              \n [88] Rcpp_1.0.11                 quantreg_5.95               dbplyr_2.3.2               \n [91] TCGAbiolinksGUI.data_1.20.0 knitr_1.43                  blob_1.2.4                 \n [94] utf8_1.2.3                  clue_0.3-64                 lme4_1.1-34                \n [97] listenv_0.9.0               checkmate_2.2.0             ggsignif_0.6.4             \n[100] tibble_3.2.1                mlr3tuningspaces_0.4.0      statmod_1.5.0              \n[103] tzdb_0.4.0                  pkgconfig_2.0.3             tools_4.3.1                \n[106] cachem_1.0.8                RSQLite_2.3.1               rvest_1.0.3                \n[109] DBI_1.1.3                   numDeriv_2016.8-1.1         mlr3filters_0.7.1          \n[112] fastmap_1.1.1               rmarkdown_2.22              scales_1.2.1               \n[115] mlegp_3.1.9                 grid_4.3.1                  mets_1.3.2                 \n[118] broom_1.0.5                 carData_3.0-5               rpart_4.1.19               \n[121] yaml_2.3.7                  foreign_0.8-84              cli_3.6.1                  \n[124] purrr_1.0.1                 lifecycle_1.0.3             askpass_1.1                \n[127] bbotk_0.7.2                 lava_1.7.2.1                kernlab_0.9-32             \n[130] backports_1.4.1             mlr3tuning_0.19.0           BiocParallel_1.34.2        \n[133] gtable_0.3.3                umap_0.2.10.0               parallel_4.3.1             \n[136] mlr3cluster_0.1.8           jsonlite_1.8.7              bitops_1.0-7               \n[139] bit64_4.0.5                 Rtsne_0.16                  mlr3learners_0.5.6         \n[142] polspline_1.1.23            survMisc_0.5.6              spacefillr_0.3.2           \n[145] htmltools_0.5.5             KMsurv_0.1-5                set6_0.2.6                 \n[148] rappdirs_0.3.3              mlr3pipelines_0.5.0-1       glue_1.6.2                 \n[151] penalizedSVM_1.1.4          mlr3viz_0.6.1               timereg_2.0.5              \n[154] XVector_0.40.0              RCurl_1.98-1.12             mclust_6.0.0               \n[157] gridExtra_2.3               boot_1.3-28.1               R6_2.5.1                   \n[160] tidyr_1.3.0                 km.ci_0.5-6                 ooplah_0.2.0               \n[163] cluster_2.1.4               beanplot_1.3.1              nloptr_2.0.3               \n[166] mlr3misc_0.13.0             vioplot_0.4.0               DelayedArray_0.26.3        \n[169] tidyselect_1.2.0            htmlTable_2.4.1             xml2_1.3.4                 \n[172] mlr3fselect_0.11.0          car_3.1-2                   AnnotationDbi_1.62.1       \n[175] future_1.33.0               munsell_0.5.0               data.table_1.14.8          \n[178] htmlwidgets_1.6.2           mlr3data_0.7.0              RColorBrewer_1.1-3         \n[181] biomaRt_2.56.1              rlang_1.1.1                 uuid_1.1-1                 \n[184] fansi_1.0.4                 prodlim_2023.03.31          psbcSpeedUp_2.0.4\n```\n\n\n::: {.cell}\n\n:::\n\n\n# References \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}