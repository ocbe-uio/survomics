[
  {
    "objectID": "survomics.html",
    "href": "survomics.html",
    "title": "Supplemental information for ‘Tutorial on survival modeling with applications to omics data’",
    "section": "",
    "text": "This is a step-by-step R tutorial using The Cancer Genome Atlas (TCGA) survival and omics data for the article Tutorial on survival modeling with applications to omics data (Z. Zhao et al. 2024)."
  },
  {
    "objectID": "survomics.html#introduction",
    "href": "survomics.html#introduction",
    "title": "Supplemental information for ‘Tutorial on survival modeling with applications to omics data’",
    "section": "Introduction",
    "text": "Introduction\nThe TCGA database provides an enormous collection of cancer data sets, including survival, clinical and multi-omics data.\n\n\n\n\n\n\nWe will use TCGA data to demonstrate:\n\n\n\n\nThe different data types\nPreprocessing of survival and omics data\nAnalysis of survival data by classical statistical methods\nUnsupervised learning for omics data\nFrequentist & Bayesian supervised learning for survival and omics data"
  },
  {
    "objectID": "survomics.html#tcga-survival-and-clinical-data",
    "href": "survomics.html#tcga-survival-and-clinical-data",
    "title": "Supplemental information for ‘Tutorial on survival modeling with applications to omics data’",
    "section": "TCGA survival and clinical data",
    "text": "TCGA survival and clinical data\nThe R/Bioconductor package TCGAbiolinks (Mounir 2019) provides a few functions to download and preprocess clinical and multi-omics data from the Genomic Data Commons (GDC) Data Portal for further analysis.\nFirst we load all necessary libraries used in this tutorial except mlr3 libraries which will be introduced later. Then we use function GDCquery_clinic() from TCGAbiolinks package to query and download TCGA survival and clinical data from multiple cancer types:\n\n\nCode\n# load all libraries used in this tutorial except mlr3\nlibrary(\"TCGAbiolinks\")\nlibrary(\"SummarizedExperiment\")\nlibrary(\"DESeq2\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"survival\")\nlibrary(\"survminer\")\nlibrary(\"M3C\")\nlibrary(\"glmnet\")\nlibrary(\"plotmo\")\nlibrary(\"grpreg\")\nlibrary(\"SGL\")\nlibrary(\"psbcGroup\")\nlibrary(\"psbcSpeedUp\")\nlibrary(\"BhGLM\")\nlibrary(\"risksetROC\")\nlibrary(\"riskRegression\")\nlibrary(\"peperr\")\nlibrary(\"c060\")\nlibrary(\"rms\")\nlibrary(\"survAUC\")\nlibrary(\"regplot\")\n\n\n\n\nCode\n# download the clinical data and extract data for multiple cancers using GDC api method\ncancer_types &lt;- c(\n  \"TCGA-BLCA\", \"TCGA-BRCA\", \"TCGA-COAD\", \"TCGA-LIHC\",\n  \"TCGA-LUAD\", \"TCGA-PAAD\", \"TCGA-PRAD\", \"TCGA-THCA\"\n)\nclin &lt;- NULL\nfor (i in seq_along(cancer_types)) {\n  tmp &lt;- TCGAbiolinks::GDCquery_clinic(project = cancer_types[i], type = \"clinical\")\n  clin &lt;- rbind(clin, tmp[, c(\n    \"project\", \"submitter_id\", \"vital_status\",\n    \"days_to_last_follow_up\", \"days_to_death\",\n    \"age_at_diagnosis\", \"gender\", \"race\",\n    \"ethnicity\", \"ajcc_pathologic_t\"\n  )])\n}\n\n# extract the observed time for each patient and use years as unit\nclin$time &lt;- apply(clin[, c(\"days_to_death\", \"days_to_last_follow_up\")], 1, max, na.rm = TRUE) / 365.25\nclin$age &lt;- clin$age_at_diagnosis / 365.25\nclin$status &lt;- clin$vital_status\nclin &lt;- clin[, c(\"project\", \"submitter_id\", \"status\", \"time\", \"gender\", \"age\", \"race\", \"ethnicity\")]\n# extract patients with positive overall survival time\nclin &lt;- clin[(clin$time &gt; 0) & (clin$status %in% c(\"Alive\", \"Dead\")), ]\n\n# frequency table of the patients w.r.t. status, gender and ethnicity\nclin %&gt;%\n  dplyr::count(status, gender, ethnicity) %&gt;%\n  group_by(status) %&gt;%\n  mutate(prop = prop.table(n))\n\n\n# A tibble: 12 × 5\n# Groups:   status [2]\n   status gender ethnicity                  n    prop\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;                  &lt;int&gt;   &lt;dbl&gt;\n 1 Alive  female hispanic or latino        75 0.0240 \n 2 Alive  female not hispanic or latino  1367 0.438  \n 3 Alive  female not reported             328 0.105  \n 4 Alive  male   hispanic or latino        34 0.0109 \n 5 Alive  male   not hispanic or latino  1041 0.334  \n 6 Alive  male   not reported             276 0.0884 \n 7 Dead   female hispanic or latino         7 0.00809\n 8 Dead   female not hispanic or latino   377 0.436  \n 9 Dead   female not reported              64 0.0740 \n10 Dead   male   hispanic or latino        10 0.0116 \n11 Dead   male   not hispanic or latino   327 0.378  \n12 Dead   male   not reported              80 0.0925 \n\n\nCode\n# censoring plot by cancer types\nID &lt;- 1:nrow(clin)\nclin %&gt;%\n  ggplot(\n    aes(y = ID, x = time, colour = project, shape = factor(status))\n  ) +\n  geom_segment(aes(x = time, y = ID, xend = 0, yend = ID)) +\n  geom_point() +\n  ggtitle(\"\") +\n  labs(x = \"Years\", y = \"Patients\") +\n  scale_shape_discrete(name = \"Status\", labels = c(\"Censored\", \"Dead\")) +\n  scale_color_discrete(\n    name = \"Cancer\",\n    labels = c(\"Bladder\", \"Breast\", \"Colon\", \"Liver\", \"Lung adeno\", \"Pancreatic\", \"Prostate\", \"Thyroid\")\n  ) +\n  theme(legend.position = \"top\", legend.direction = \"vertical\") +\n  guides(color = guide_legend(nrow = 2, byrow = TRUE))\n\n\n\n\n\nOverall survival times and status of pan-cancer patients from TCGA."
  },
  {
    "objectID": "survomics.html#tcga-omics-data",
    "href": "survomics.html#tcga-omics-data",
    "title": "Supplemental information for ‘Tutorial on survival modeling with applications to omics data’",
    "section": "TCGA omics data",
    "text": "TCGA omics data\nWe use function GDCquery() to query and use GDCdownload() and GDCprepare() to download TCGA omics data from one cancer type (breast cancer). The argument data.category in function GDCquery() specifies the type of omics data, such as \"Copy Number Variation\", \"DNA Methylation\", \"Transcriptome Profiling\", \"Simple Nucleotide Variation\". Note that the downloaded omics data are accompanied by metadata including survival outcomes, clinical and demographic variables. The accompanied metadata are almost the same as the clinical data downloaded via GDCquery_clinic() in the previous section but here only corresponding to one cancer type.\n\n\nCode\n# download TCGA breast cancer (BRCA) mRNA-Seq data using GDC api method\nquery &lt;- TCGAbiolinks::GDCquery(\n  project = \"TCGA-BRCA\",\n  data.category = \"Transcriptome Profiling\",\n  data.type = \"Gene Expression Quantification\",\n  workflow.type = \"STAR - Counts\",\n  experimental.strategy = \"RNA-Seq\",\n  sample.type = c(\"Primary Tumor\")\n)\nTCGAbiolinks::GDCdownload(query = query, method = \"api\")\ndat &lt;- TCGAbiolinks::GDCprepare(query = query)\n\nSummarizedExperiment::assays(dat)$unstranded[1:5, 1:2]\n\n\n                   TCGA-A7-A26E-01B-06R-A277-07 TCGA-A2-A0CU-01A-12R-A034-07\nENSG00000000003.15                          691                         1429\nENSG00000000005.6                            20                           73\nENSG00000000419.13                          335                         1674\nENSG00000000457.14                         1292                         1018\nENSG00000000460.17                          536                          450\nIt is recommended to use DESeq2 or TMM normalization method for RNA-seq data before further statistical analysis (Y. Zhao et al. 2021). Here we demonstrate how to use the R/Bioconductor package DESeq2 (Love, Huber, and Anders 2014) to normalize the RNA count data.\n\n\nCode\nmeta &lt;- colData(dat)[, c(\"project_id\", \"submitter_id\", \"age_at_diagnosis\", \"ethnicity\", \"gender\", \"days_to_death\", \"days_to_last_follow_up\", \"vital_status\", \"paper_BRCA_Subtype_PAM50\", \"treatments\")]\nmeta$treatments &lt;- unlist(lapply(meta$treatments, function(xx) {\n  any(xx$treatment_or_therapy == \"yes\")\n}))\ndds &lt;- DESeq2::DESeqDataSetFromMatrix(assays(dat)$unstranded, colData = meta, design = ~1)\ndds2 &lt;- DESeq2::estimateSizeFactors(dds)\nRNA_count &lt;- DESeq2::counts(dds2, normalized = TRUE)\nRNA_count[1:5, 1:2]\n\n\n                   TCGA-A7-A26E-01B-06R-A277-07 TCGA-A2-A0CU-01A-12R-A034-07\nENSG00000000003.15                   1899.76848                   1419.51789\nENSG00000000005.6                      54.98606                     72.51561\nENSG00000000419.13                    921.01656                   1662.89219\nENSG00000000457.14                   3552.09968                   1011.24507\nENSG00000000460.17                   1473.62649                    447.01403\nTo perform survival analysis with both clinical/demographic variables and omics data, in the following code we extract female breast cancer patients with their corresponding survival outcomes, clinical/demographic variables and RNA-seq features.\n\n\nCode\nmeta$time &lt;- apply(meta[, c(\"days_to_death\", \"days_to_last_follow_up\")], 1, max, na.rm = TRUE) / 365.25\nmeta$status &lt;- meta$vital_status\nmeta$age &lt;- meta$age_at_diagnosis / 365.25\nclin &lt;- subset(meta, gender == \"female\" & !duplicated(submitter_id) & time &gt; 0 & !is.na(age))\nclin &lt;- clin[order(clin$submitter_id), ]\nRNA_count &lt;- RNA_count[, rownames(clin)]\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nBioconductor might provide an outdated version of TCGAbiolinks. Here, we use the GitHub version TCGAbiolinks_2.29.6. If you encounter some issues when using this tutorial, please check your installed TCGAbiolinks version. If necessary, you can re-install the package from its GitHub repository. Otherwise, download the data from  and load the dat object with: load(\"TCGA_data.rda\").\nThe package TCGAbiolinks cannot retrieve any proteomics or metabolomics data. It is always useful to look at your data first, in particular the data type and dimensions (i.e. numbers of rows and columns for a data frame or matrix)."
  },
  {
    "objectID": "survomics.html#survival-analysis-with-low-dimensional-input-data",
    "href": "survomics.html#survival-analysis-with-low-dimensional-input-data",
    "title": "Supplemental information for ‘Tutorial on survival modeling with applications to omics data’",
    "section": "Survival analysis with low-dimensional input data",
    "text": "Survival analysis with low-dimensional input data\n\nNonparametric survival analysis\nFor the data of TCGA breast cancer patients that we extracted in the previous section, Kaplan-Meier estimates of the survival probabilities can be obtained via function survfit() from survival package. The dashed lines in the following figure indicate the median survival time.\n\n\nCode\n# Kaplan-Meier (KM) estimation\nclin$status[clin$status == \"Dead\"] &lt;- 1\nclin$status[clin$status == \"Alive\"] &lt;- 0\nclin$status &lt;- as.numeric(clin$status)\nsfit &lt;- survival::survfit(Surv(time, status) ~ 1, data = clin)\n\n# calculate survival probability at 1-, 3- and 5-year time points\nsummary(sfit, times = c(1, 3, 5))\ntheme_set(theme_bw())\nggsurv &lt;- survminer::ggsurvplot(sfit,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\",\n  legend = \"none\", surv.median.line = \"hv\"\n)\nggsurv$plot &lt;- ggsurv$plot + annotate(\"text\", x = 20, y = 0.9, label = \"+  Censor\")\nggsurv\n\n\n\n\n\nKaplan-Meier curve for 1061 BRCA patients data from TCGA.\n\n\n\nTo compare the survival curves of two groups of patients, for example, treatment (i.e. pharmaceutical or radiation therapy) or nontreatment, the R function survival::survdiff() can perform the log-rank test to compare two survival curves. Alternatively, the R function survival::survfit with a formula including the treatment group as a covariate can return the (KM) survival probabilities for each groups. Then the R function survminer::ggsurvplot() with a survfit object will draw the two survival curves and perform the log-rank test as shown in the following figure.\n\n\nCode\nsurvival::survdiff(Surv(time, status) ~ treatments, data = clin)\n\nsfit2 &lt;- survfit(Surv(time, status) ~ treatments, data = clin)\nggsurv &lt;- ggsurvplot(sfit2,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\", legend = c(.6, .9),\n  legend.labs = c(\"No\", \"Yes\"), legend.title = \"Treatment\",\n  risk.table.y.text.col = TRUE, risk.table.y.text = FALSE\n)\nggsurv$plot &lt;- ggsurv$plot +\n  annotate(\"text\", x = 21, y = 1, label = \"+  Censor\") +\n  annotate(\"text\", x = 22, y = .88, label = paste0(\"Log-rank test:\\n\", surv_pvalue(sfit2)$pval.txt))\nggsurv\n\n\n\n\n\nKaplan-Meier curves of the BRCA patients’ survival data from TCGA grouped by treatment (i.e. pharmaceutical or radiation therapy) or nontreatment. The log-rank test is to compare the two survival distributions corresponding to the two groups of patients.\n\n\n\nTo analyze if a continuous variable, e.g. age, is associated with the survival outcomes, we can use the R function coxph() for fitting a Cox model, which is similar to the function lm() for fitting linear models.\n\n\nCode\nfit_cox &lt;- coxph(Surv(time, status) ~ age, data = clin)\nsummary(fit_cox)\n\n\nCall:\ncoxph(formula = Surv(time, status) ~ age, data = clin)\n\n  n= 1047, number of events= 149 \n   (14 observations deleted due to missingness)\n\n        coef exp(coef) se(coef)     z Pr(&gt;|z|)    \nage 0.034244  1.034837 0.006703 5.109 3.24e-07 ***\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n    exp(coef) exp(-coef) lower .95 upper .95\nage     1.035     0.9663     1.021     1.049\n\nConcordance= 0.639  (se = 0.029 )\nLikelihood ratio test= 26.34  on 1 df,   p=3e-07\nWald test            = 26.1  on 1 df,   p=3e-07\nScore (logrank) test = 26.63  on 1 df,   p=2e-07\nThe Cox model assumes proportional hazards and log-linearity of the covariates. To check the log-linearity for a clinical or demographic variable, e.g. age, we can fit a penalized smoothing spline for age effect. The following code shows that the nonlinear part of the smoothing spline has a significant effect (\\(p = 0.00013\\)). Thus, the assumption of log-linearity for age is not satisfied.\n\n\nCode\nfit_cox_spline &lt;- coxph(Surv(time, status) ~ pspline(age), data = clin)\nfit_cox_spline\n\n\nCall:\ncoxph(formula = Surv(time, status) ~ pspline(age), data = clin)\n\n                         coef se(coef)      se2    Chisq   DF       p\npspline(age), linear  0.03509  0.00577  0.00577 36.98323 1.00 1.2e-09\npspline(age), nonlin                            20.69146 3.03 0.00013\n\nIterations: 5 outer, 15 Newton-Raphson\n     Theta= 0.828 \nDegrees of freedom for terms= 4 \nLikelihood ratio test=46.4  on 4.03 df, p=2e-09\nn= 1047, number of events= 149 \nTo check proportional hazards of age, we can add a time-dependent covariate \\(age \\times g(t)\\), where \\(g(t)\\) is a known function e.g. \\(g(t) = \\log t\\). The following code shows that the time-dependent age is significant using a score test (\\(p = 0.0087\\)). Thus, the assumption of proportional hazards for age is not satisfied. The above two tests indicate a non-loglinear or time-dependent association of age with the survival outcomes.\n\n\nCode\nsurvival::cox.zph(fit_cox, transform = \"log\")\n\n\n       chisq df    p\nage     6.88  1 0.0087\nGLOBAL  6.88  1 0.0087\n\nHere the approaches for checking log-linearity or proportional hazards can only be used in low-dimensional data settings. When including high-dimensional omics data, there are no standard approaches for checking log-linearity or proportional hazards currently.\n\n\n\n\nFeature preselection/filtering\nFrom a practical point of view, since most omics profiles contain thousands of variables and most supervised statistical methods are not suited for high dimensional omics features, it is better to filter the omics features first. In addition, we perceive that not too many omics features are relevant to one medical problem. We will demonstrate three different filtering approaches for high-dimensional omics data:\n\nKnowledge-based filtering\nP-value-based filtering\nVariance-based filtering\n\n\nKnowledge filter\nOne can be interested in only some biologically meaningful genes or only protein-coding genes in a specific study. For example, the code below filters protein-coding genes.\n\n\nCode\nfiltered_rna &lt;- RNA_count[rowData(dat)$gene_type == \"protein_coding\", ]\n\n\n\n\nP-value filter\nBefore joint analyzing the associations between the thousands of omics features and survival outcomes, one can analyze the association between each omics feature and the survival outcomes, and filter omics features at a statistical significance level \\(0.1\\) or \\(0.2\\) (larger than 0.05 to reduce false negative identification of omics features in multivariate analysis). For demonstration, based on the \\(100\\) mRNA-Seq features from TCGA breast cancer patients preprocessed previously, the code below filters omics features at the statistical significance level \\(0.2\\), i.e. \\(p &lt; 0.2\\).\n\n\nCode\nRNA_log2count &lt;- log2(RNA_count[1:100, ] + 1)\npvalues &lt;- rep(NA, nrow(RNA_log2count))\nfor (j in 1:nrow(RNA_log2count)) {\n  fit_cox &lt;- coxph(Surv(clin$time, clin$status) ~ RNA_log2count[j, ], data = clin)\n  pvalues[j] &lt;- summary(fit_cox)$coefficients[, \"Pr(&gt;|z|)\"]\n}\nfiltered_rna &lt;- RNA_log2count[which(pvalues &lt; 0.2), ]\n\n\n\n\nVariance filter\nThe other common and easy way to decrease the number of omics features is to filter the most variable ones for further analysis. Note that the variance-based filtering step should be done before data standardization (i.e. calculating \\(z\\)-score), but can be performed after count data normalization and log2-transformation for instance.\nThe R package M3C (John et al. 2020) provides a filter function featurefilter() by using different variance-type metrics, for example, variance, median absolute deviation (MAD), coefficient of variation (A) and its second order derivative (A2). The simple variance filter can be used if the variance does not change with the corresponding mean, otherwise the coefficient of variation can be used. If the omics data include outliers, MAD filter is more robust than the variance filter. Based on the \\(60660\\) mRNA-Seq features from TCGA breast cancer patients preprocessed previously, the code below extracts the \\(1\\%\\) most variable features using variance as a filtering metric.\n\n\nCode\nRNA_log2count &lt;- log2(RNA_count + 1)\nfiltered &lt;- M3C::featurefilter(RNA_log2count, percentile = 1, method = \"var\", topN = 5)\nfiltered_rna1 &lt;- filtered$filtered_data\n\n\n***feature filter function***\nextracting the most variable: 1 percent\nfeatures to start with: 60660\nperforming calculations for variance\nprinting topN most variable features with statistics...\n                              feature      mean      var       sd\nENSG00000166509.12 ENSG00000166509.12  6.086125 31.60384 5.621729\nENSG00000110484.7   ENSG00000110484.7 11.005136 26.13755 5.112489\nENSG00000153002.12 ENSG00000153002.12  8.212895 25.89105 5.088325\nENSG00000134184.13 ENSG00000134184.13  5.371435 23.23511 4.820281\nENSG00000160182.3   ENSG00000160182.3  9.902195 21.41407 4.627534\nfeatures remaining: 607\nAnother variance-type filter is to remain features with certain percentage of cumulative variances, which will usually filter fewer features than the approaches above. The code below extracts the most variable features explaining \\(1\\%\\) cumulative variances.\n\n\nCode\ncumsum_var &lt;- cumsum(filtered$statistics$var)\ncumsum_cutoff &lt;- cumsum_var[length(cumsum_var)] * 0.01\nfiltered_names &lt;- filtered$statistics$feature[cumsum_var &lt; cumsum_cutoff]"
  },
  {
    "objectID": "survomics.html#survival-analysis-with-high-dimensional-input-data",
    "href": "survomics.html#survival-analysis-with-high-dimensional-input-data",
    "title": "Supplemental information for ‘Tutorial on survival modeling with applications to omics data’",
    "section": "Survival analysis with high-dimensional input data",
    "text": "Survival analysis with high-dimensional input data\n\nUnsupervised learning (omics data)\nIn this section we will use the mRNA-Seq data of breast cancer patients from TCGA. The following unsupervised methods can be applied to other omics data as well (the same applies to the supervised learning methods). One important thing is that the input omics data, especially the data type and dimensions, should be suited to the methods.\nUnsupervised learning for omics data can be helpful to explore subpopulations of the data, for example, patients from one cancer type can be divided to several omics-related subtypes. We demonstrate three unsupervised learning methods, i.e. principal component analysis (PCA), \\(t\\)-stochastic neighbour embedding (\\(t\\)-SNE) and uniform manifold approximation and projection (UMAP), based on the PAM50 genes (Parker et al. 2009). The R package M3C (John et al. 2020) provides the analyses and visualization of all the three methods.\n\n\nCode\n# identify indexes of the PAM50 genes in the TCGA-BRCA data\nidx &lt;- which(rowData(dat)$gene_name %in%\n  c(\"UBE2T\", \"BIRC5\", \"NUF2\", \"CDC6\", \"CCNB1\", \"TYMS\", \"MYBL2\", \"CEP55\", \"MELK\", \"NDC80\", \"RRM2\", \"UBE2C\", \"CENPF\", \"PTTG1\", \"EXO1\", \"ORC6\", \"ANLN\", \"CCNE1\", \"CDC20\", \"MKI67\", \"KIF2C\", \"ACTR3B\", \"MYC\", \"EGFR\", \"KRT5\", \"PHGDH\", \"CDH3\", \"MIA\", \"KRT17\", \"FOXC1\", \"SFRP1\", \"KRT14\", \"ESR1\", \"SLC39A6\", \"BAG1\", \"MAPT\", \"PGR\", \"CXXC5\", \"MLPH\", \"BCL2\", \"MDM2\", \"NAT1\", \"FOXA1\", \"BLVRA\", \"MMP11\", \"GPR160\", \"FGFR4\", \"GRB7\", \"TMEM45B\", \"ERBB2\"))\n# extract the PAM50 genes of TCGA-BRCA patients\nTCGA_PAM50 &lt;- RNA_count[idx, ]\n# use gene symbols instead of Ensembl IDs\nrownames(TCGA_PAM50) &lt;- rowData(dat)$gene_name[idx]\n\n# log2-transformation of the normalized count data\nTCGA_PAM50 &lt;- log2(TCGA_PAM50 + 1)\npam50 &lt;- factor(clin$paper_BRCA_Subtype_PAM50)\n\nM3C::pca(TCGA_PAM50, labels = pam50, dotsize = 3, legendtitle = \"Subtype\")\n\n\n\n\n\nUnsupervised clustering (principal component analysis, PCA) of transcriptomic data from TCGA breast cancer patients\n\n\n\n\nCode\nM3C::tsne(TCGA_PAM50, labels = pam50, dotsize = 3, legendtitle = \"Subtype\")\n\n\n\n\n\nUnsupervised clustering (\\(t\\)-stochastic neighbour embedding, \\(t\\)-SNE) of transcriptomic data from TCGA breast cancer patients\n\n\n\n\nCode\nM3C::umap(TCGA_PAM50, labels = pam50, dotsize = 3, legendtitle = \"Subtype\")\n\n\n\n\n\nUnsupervised clustering (uniform manifold approximation and projection, UMAP) of transcriptomic data from TCGA breast cancer patients\n\n\n\n\n\nSupervised learning (omics and survival data)\nTo investigate the relationship between omics features and survival outcomes, regression methods (i.e. supervised learning) can be applied. Since omics data are high-dimensional, one can use unsupervised learning methods to summarize a few components (dimension reduction) and regress the survival outcomes on the low-dimensional components by some classical statistical methods, e.g. classical Cox model. There are also frequentist and Bayesian supervised learning methods suited to directly regress the survival outcomes on the high-dimensional omics features. Note that preselecting/filtering ultrahigh-dimensional omics features can be useful before running the frequentist and Bayesian supervised learning methods.\n\nDimension reduction for Cox models\nThe following code demonstrates the use of the first two principal components of PCA as covariates for the purpose of survival prediction. Similarly, the first components from \\(t\\)-SNE or UMAP can also be extracted as covariates.\n\n\nCode\n# principal component regression\nx_tmp &lt;- prcomp(t(TCGA_PAM50))\n\n# choose the top two components (subjective) as covariates\nX_PC &lt;- x_tmp$x[, 1:2]\n# build classical survival model (e.g. PH Cox model)\ndata_tmp &lt;- data.frame(time = clin$time, status = clin$status, X_PC)\nfit &lt;- coxph(Surv(time, status) ~ PC1 + PC2, data = data_tmp)\nsummary(fit)\n\n\nCall:\ncoxph(formula = Surv(time, status) ~ PC1 + PC2, data = data_tmp)\n\n  n= 1047, number of events= 149 \n\n        coef exp(coef) se(coef)     z Pr(&gt;|z|)   \nPC1 0.004679  1.004690 0.009675 0.484  0.62862   \nPC2 0.038179  1.038918 0.013233 2.885  0.00391 **\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n    exp(coef) exp(-coef) lower .95 upper .95\nPC1     1.005     0.9953    0.9858     1.024\nPC2     1.039     0.9625    1.0123     1.066\n\nConcordance= 0.58  (se = 0.028 )\nLikelihood ratio test= 8.54  on 2 df,   p=0.01\nWald test            = 8.64  on 2 df,   p=0.01\nScore (logrank) test = 8.66  on 2 df,   p=0.01\n\n\nPenalized Cox models\nFor computational efficiency, we will use only the mRNA-Seq features corresponding to the PAM50 genes (Parker et al. 2009) instead of the variance filtered genes from the previous section. We perform an investigation of the relationships between the mRNA-Seq features, two clinical variables (i.e. the patients’ age at diagnosis and their ethnicity) and the survival outcomes.\nThe R package glmnet (Friedman, Hastie, and Tibshirani 2010) is very computationally efficient to run Lasso and Elastic Net Cox models. Lasso has a tuning parameter \\(\\lambda\\) to control the penalty strength of the coefficients which can be optimized by cross-validation (CV) via function cv.glmnet(). The glmnet() and cv.glmnet() functions provide the argument penalty.factor to allow different shrinkage for different features, which makes sense if one includes both clinical/demographic variables and omics features and does not want to perform feature selection for the clinical/demographic variables.\n\n\nCode\n## Lasso Cox model\n\n## for demonstration simplicity, PAM50 genes are used here\nx &lt;- cbind(age = clin$age, ethnicity = factor(clin$ethnicity), t(TCGA_PAM50))\ny &lt;- cbind(time = clin$time, status = clin$status)\n\n# set penalty factor without penalizing the two demographical variables\npf &lt;- c(rep(0, 2), rep(1, ncol(x) - 2))\n\n# Lasso Cox by using cv.glmnet to obtain the 5-fold CV optimal lambda.min or lambda.1se\nset.seed(123)\ncvfit &lt;- glmnet::cv.glmnet(x, y, family = \"cox\", nfolds = 5, penalty.factor = pf)\nmod &lt;- cvfit$glmnet.fit\nlambda_optimal &lt;- cvfit$lambda.min # optimal lambda\n\nbetas &lt;- as.vector(coef(mod, s = lambda_optimal))\nbeta.positive &lt;- colnames(x)[betas &gt; 0]\nbeta.negative &lt;- colnames(x)[betas &lt; 0]\n# get ordered list of variables as they appear at smallest lambda\nallnames &lt;- names(coef(mod)[, ncol(coef(mod))]\n[order(coef(mod)[, ncol(coef(mod))], decreasing = TRUE)])\n# assign colors for positive (pink) and negative (green) coefficients\ncols &lt;- rep(\"gray80\", length(allnames))\ncols[allnames %in% beta.positive] &lt;- \"seagreen3\"\ncols[allnames %in% beta.negative] &lt;- \"hotpink\"\n\n# draw coefficient paths of a Lasso Cox model\nplotmo::plot_glmnet(mod,\n  label = TRUE, s = lambda_optimal, col = cols,\n  xlab = expression(log ~ ~lambda), ylab = expression(beta)\n)\ntitle(\"Lasso    \\n\\n\")\n\n\n\n\n\nCoefficient paths of a Lasso Cox model. The verticle gray line indicates the optimal \\(\\lambda\\) and its correspondingly selected features are marked as green (positive coefficient) and red (negative coefficient) colors. Note that the demographic variables age and ethnicity were not penalized, so that their coefficient paths did not start from zero in the figure.\n\n\n\nElastic Net Cox model includes the \\(\\lambda\\) and an additional penalty parameter \\(\\alpha \\in [0,1]\\). The parameter \\(\\alpha\\) can be fixed as \\(0\\) (Ridge), \\(1\\) (Lasso) or any value between \\(0\\) and \\(1\\) for making a compromise between Ridge and Lasso, which can also be optimized by cross-validation manually, see the example below.\n\n\nCode\n## Elastic Net Cox model\n\n# set penalty parameter alpha which comprises between Lasso and ridge regressions\nalpha &lt;- seq(0.1, 1, length = 10)\nfitEN &lt;- list()\nset.seed(123)\nfor (i in 1:length(alpha)) {\n  fitEN[[i]] &lt;- cv.glmnet(x, y, family = \"cox\", alpha = alpha[i], nfolds = 5, penalty.factor = pf)\n}\nidx &lt;- which.min(sapply(fitEN, function(xx) {\n  xx$cvm[xx$lambda == xx$lambda.min]\n}))\ncvfit &lt;- fitEN[[idx]]\n\n# the following code is the same as Lasso previously\nmod &lt;- cvfit$glmnet.fit\nlambda_optimal &lt;- cvfit$lambda.min # optimal lambda\n\nbetas &lt;- as.vector(coef(mod, s = lambda_optimal))\nbeta.positive &lt;- colnames(x)[betas &gt; 0]\nbeta.negative &lt;- colnames(x)[betas &lt; 0]\nallnames &lt;- names(coef(mod)[, ncol(coef(mod))]\n[order(coef(mod)[, ncol(coef(mod))], decreasing = TRUE)])\ncols &lt;- rep(\"gray80\", length(allnames))\ncols[allnames %in% beta.positive] &lt;- \"seagreen3\"\ncols[allnames %in% beta.negative] &lt;- \"hotpink\"\n\nplotmo::plot_glmnet(mod,\n  label = TRUE, s = lambda_optimal, col = cols,\n  xlab = expression(log ~ ~lambda), ylab = expression(beta)\n)\ntitle(\"Elastic Net     \\n\\n\")\n\n\n\n\n\nCoefficient paths of an Elastic Net Cox model. The verticle gray line indicates the optimal \\(\\lambda\\) and its correspondingly selected features are marked as green (positive coefficient) and red (negative coefficient) colors. Note that the demographic variables age and ethnicity were not penalized, so that their coefficient paths did not start from zero in the figure.\n\n\n\nAdaptive Lasso Cox model needs to pre-estimate all coefficients which will be used as weights via the argument penalty.factor in the glmnet() and cv.glmnet() functions to fit a Lasso Cox model. The pre-estimation can be done by a Ridge Cox model, see an example below.\n\n\nCode\n## Adaptive Lasso Cox model\n\nset.seed(123)\nfit &lt;- cv.glmnet(x, y, family = \"cox\", alpha = 0, nfolds = 5)\nweights &lt;- abs(1 / as.vector(coef(fit, s = \"lambda.min\")))\nweights[c(1,2)] = 0 # don't penalize age and ethnicity\n\n# adaptive Lasso Cox by using cv.glmnet to obtain the 5-fold CV optimal lambda.min or lambda.1se\ncvfit &lt;- cv.glmnet(x, y, family = \"cox\", nfolds = 5, penalty.factor = weights)\nmod &lt;- cvfit$glmnet.fit\nlambda_optimal &lt;- cvfit$lambda.min # optimal lambda\n\nbetas &lt;- as.vector(coef(mod, s = lambda_optimal))\nbeta.positive &lt;- colnames(x)[betas &gt; 0]\nbeta.negative &lt;- colnames(x)[betas &lt; 0]\n# get ordered list of variables as they appear at smallest lambda\nallnames &lt;- names(coef(mod)[, ncol(coef(mod))]\n[order(coef(mod)[, ncol(coef(mod))], decreasing = TRUE)])\n# assign colors\ncols &lt;- rep(\"gray80\", length(allnames))\ncols[allnames %in% beta.positive] &lt;- \"seagreen3\"\ncols[allnames %in% beta.negative] &lt;- \"hotpink\"\n\nplot_glmnet(mod,\n  label = TRUE, s = lambda_optimal, col = cols,\n  xlab = expression(log ~ lambda), ylab = expression(beta)\n)\ntitle(\"Adative Lasso    \\n\\n\")\n\n\n\n\n\nCoefficient paths of an adaptive Lasso Cox model. The verticle gray line indicates the optimal \\(\\lambda\\) and its correspondingly selected features are marked as green (positive coefficient) and red (negative coefficient) colors. Note that the demographic variables age and ethnicity were not penalized, so that their coefficient paths did not start from zero in the figure.\n\n\n\nGroup Lasso Cox model can be implemented through the R package grpreg (Breheny and Huang 2015). For an illustration, we specify the two demographic variables as the first group, the first \\(10\\) PAM50 genes as the second group, the last \\(40\\) PAM50 genes as the third group. A \\(k\\)-fold cross-validation (CV) for the group Lasso Cox model is performed through function cv.grpsurv(). The returned object cvfit$lambda.min is the value of CV-optimized \\(\\lambda\\). The following results show that\n\nwhen choosing the CV-optimized \\(\\lambda = 0.0143\\) (output matrix has lambda values as column names), the estimated coefficients of the first two groups are nonzero (i.e. selecting first and second groups);\nwhen choosing the \\(10\\)-th lambda \\(\\lambda = 0.0217\\), only the first group of covariates has nonzero coefficients (i.e. selecting first group);\nwhen choosing the \\(15\\)-th lambda \\(\\lambda = 0.0108\\), the estimated coefficients of all the three groups are nonzero (i.e. selecting all groups).\n\nNote that the R package grpreg (Breheny and Huang 2015) also implements group smoothly clipped absolute deviation (SCAD) model and some others, see Breheny, Zeng, and Kurth (2021) for details.\n\n\nCode\n# group Lasso Cox model\ngroup &lt;- c(rep(\"demographic\", 2), rep(\"PAM50_1\", 10), rep(\"PAM50_2\", 40))\ngroup &lt;- factor(group)\nset.seed(123)\ncvfit &lt;- grpreg::cv.grpsurv(X = x, y = y, group = group, penalty = \"grLasso\", returnY = TRUE)\nround(cvfit$fit$beta[, c(which.min(cvfit$cve), 10, 20)], digits = 4)\n\n\n           0.0143  0.0217  0.0108\nage        0.0218  0.0154  0.0247\nethnicity -0.0542 -0.0425 -0.0570\nANLN       0.0193  0.0000  0.0713\nFOXC1     -0.0032  0.0000 -0.0104\nCDH3      -0.0028  0.0000 -0.0090\nUBE2T      0.0154  0.0000  0.0571\nNDC80     -0.0239  0.0000 -0.0862\nPGR       -0.0027  0.0000 -0.0086\nBIRC5     -0.0133  0.0000 -0.0497\nORC6       0.0140  0.0000  0.0489\nESR1      -0.0002  0.0000 -0.0008\nPHGDH      0.0008  0.0000  0.0024\nCDC6       0.0000  0.0000 -0.0094\nMMP11      0.0000  0.0000  0.0074\nMYBL2      0.0000  0.0000  0.0018\nSFRP1      0.0000  0.0000  0.0049\nCCNE1      0.0000  0.0000  0.0000\nBLVRA      0.0000  0.0000 -0.0436\nBAG1       0.0000  0.0000 -0.0163\nMLPH       0.0000  0.0000 -0.0155\nCDC20      0.0000  0.0000 -0.0129\nCENPF      0.0000  0.0000 -0.0245\nKRT17      0.0000  0.0000 -0.0125\nFOXA1      0.0000  0.0000  0.0040\nACTR3B     0.0000  0.0000 -0.0112\nCCNB1      0.0000  0.0000  0.0302\nMDM2       0.0000  0.0000 -0.0077\nMYC        0.0000  0.0000  0.0002\nCEP55      0.0000  0.0000 -0.0242\nSLC39A6    0.0000  0.0000  0.0053\nERBB2      0.0000  0.0000 -0.0089\nGRB7       0.0000  0.0000  0.0099\nKIF2C      0.0000  0.0000  0.0219\nNUF2       0.0000  0.0000  0.0210\nEGFR       0.0000  0.0000 -0.0150\nMKI67      0.0000  0.0000  0.0266\nTMEM45B    0.0000  0.0000  0.0100\nFGFR4      0.0000  0.0000  0.0023\nPTTG1      0.0000  0.0000  0.0095\nMELK       0.0000  0.0000 -0.0188\nNAT1       0.0000  0.0000 -0.0052\nCXXC5      0.0000  0.0000  0.0131\nBCL2       0.0000  0.0000 -0.0082\nRRM2       0.0000  0.0000 -0.0003\nGPR160     0.0000  0.0000 -0.0043\nEXO1       0.0000  0.0000  0.0041\nUBE2C      0.0000  0.0000 -0.0052\nTYMS       0.0000  0.0000 -0.0298\nKRT5       0.0000  0.0000 -0.0025\nKRT14      0.0000  0.0000  0.0085\nMAPT       0.0000  0.0000 -0.0071\nMIA        0.0000  0.0000 -0.0180\nSparse group Lasso Cox model is implemented in the R package SGL (N. Simon et al. 2019). The function cvSGL() uses cross validation to optimize the penalty parameter \\(\\lambda\\). The following example shows that it induces sparsity in each group of covariates.\n\n\nCode\n# sparse group Lasso Cox model\ngroup &lt;- c(rep(\"demographic\", 2), rep(\"PAM50_1\", 10), rep(\"PAM50_2\", 40))\ngroup &lt;- factor(group)\ndat_tmp &lt;- list(x = x, time = clin$time, status = clin$status)\nset.seed(123)\ncvfit &lt;- SGL::cvSGL(dat_tmp, index = group, type = \"cox\", nfold = 5)\nbeta.hat &lt;- cvfit$fit$beta[, which.min(cvfit$lldiff)]\nnames(beta.hat) &lt;- paste0(\"group\", as.numeric(group), \".\", c(1:2, 1:10, 1:40))\nbeta.hat\n\n\n     group1.1      group1.2      group2.1      group2.2      group2.3      group2.4 \n 5.6584838488  0.0000000000  0.4812006103  0.0000000000  0.0000000000  0.2481830177 \n     group2.5      group2.6      group2.7      group2.8      group2.9     group2.10 \n 0.0000000000 -0.0003042126  0.0000000000  0.3317385412  0.0000000000  0.0000000000 \n     group3.1      group3.2      group3.3      group3.4      group3.5      group3.6 \n 0.0000000000  0.3037631224  0.0000000000 -0.3782338997  0.0000000000 -2.6805881347 \n     group3.7      group3.8      group3.9     group3.10     group3.11     group3.12 \n-1.8418523757  0.0000000000  0.0000000000  0.0000000000 -1.7849923007  0.0000000000 \n    group3.13     group3.14     group3.15     group3.16     group3.17     group3.18 \n 0.0000000000  1.0290918041  0.0000000000  0.0000000000  0.0000000000  0.0000000000 \n    group3.19     group3.20     group3.21     group3.22     group3.23     group3.24 \n 0.0000000000  0.0000000000  0.0000000000  0.0000000000 -0.3679980817  0.0000000000 \n    group3.25     group3.26     group3.27     group3.28     group3.29     group3.30 \n 0.9925901529  0.0088469957  0.0000000000  0.0000000000  0.0000000000  0.0000000000 \n    group3.31     group3.32     group3.33     group3.34     group3.35     group3.36 \n-2.1975942364  0.0000000000  0.0000000000  0.0000000000  0.0000000000 -0.8407228093 \n    group3.37     group3.38     group3.39     group3.40 \n-1.8217490477  0.0000000000 -0.7323739107 -2.0111900380 \n\n\nSparse Bayesian Cox models\nThe R package psbcGroup (Lee, Chakraborty, and Sun 2021) integrates a large set of sparse Bayesian Cox models. The function psbcGL() implements Bayesian Cox models with Lasso and group Lasso priors for feature selection and group selection respectively. For the Lasso prior, set the hyperparameter priorPara$groupInd = 1:p where \\(p\\) is the total number of covariates. For the group Lasso prior, set the hyperparameter priorPara$groupInd as a vector of size \\(p\\), where each element denotes which group each covariate corresponds to.\n\n\nCode\n# Bayesian Cox model with Lasso prior\n\nset.seed(123)\nsurvObj &lt;- list(t = clin$time, di = clin$status, x = x)\np &lt;- ncol(x)\n# set hyperparameters.\n# For Lasso prior (i.e. 'groupInd'= 1:p), larger ratio r/delta tends to force the posterior betas to be more concentrated at 0\n# For group Lasso prior (i.e. 'groupInd' as group indicator for covariates), larger ratio r/delta tends to force stronger grouping effect of covariates\ns &lt;- c(sort(survObj$t[survObj$di == 1]), 2 * max(survObj$t) - max(survObj$t[-which(survObj$t == max(survObj$t))]))\npriorPara &lt;- list(\n  \"eta0\" = 1, \"kappa0\" = 1, \"c0\" = 2, \"r\" = 0.5,\n  \"delta\" = 0.0001, \"s\" = s, \"J\" = length(s), \"groupInd\" = 1:p\n)\n# set MCMC parameters\nmcmcPara &lt;- list(\"numBeta\" = p, \"beta.prop.var\" = 1)\n# set initial values of hyperparameters\nlambdaSq &lt;- 1\ninitial &lt;- list(\n  \"beta.ini\" = rep(0, p), \"lambdaSq\" = 1, \"sigmaSq\" = runif(1, 0.1, 10),\n  \"tauSq\" = rexp(length(unique(priorPara$groupInd)), \"rate\" = lambdaSq / 2),\n  \"h\" = rgamma(priorPara$J, 1, 1)\n)\n# in real applications, 'num.reps' should be large enough (e.g. 20000, 40000) and 'chain' to be &gt; 1\n# argument 'rw' should be FALSE for high-dimensional covariates\nBayesLassofit &lt;- psbcGroup::psbcGL(survObj, priorPara, initial, rw = TRUE, mcmcPara, num.reps = 100, thin = 1, chain = 1)\n# burn-in the first half MCMC iterations\nbeta_p &lt;- BayesLassofit$beta.p[-(1:51), ]\ncolnames(beta_p) &lt;- colnames(x)\npsbcSpeedUp:::plot.psbcSpeedUp(beta_p)\n\n\n\n\n\nEstimates of regression coefficients by a penalized semiparametric Bayesian Cox model with Lasso prior. Solid dots indicate the posterior mean over MCMC iterations (excluding burn-in period), and horizontal lines show the corresponding 95% credibility intervals.\n\n\n\nNote that psbcGroup cannot distinguish mandatory (unpenalized) covariates with omics features, see Zucknick, Saadati, and Benner (2015) for an extended Bayesian Lasso Cox model.  The following code implements the Bayesian Lasso Cox model with mandatory covariates through the R package psbcSpeedUp (Z. Zhao et al. 2023).\n\n\nCode\n# Bayesian Cox model with Lasso prior and mandatory covariates\nset.seed(123)\nsurvObjM &lt;- list(t = clin$time, di = clin$status, x = x[, c(3:52, 1:2)])\npriorPara &lt;- list(\"eta0\" = 1, \"kappa0\" = 1, \"c0\" = 2, \"r\" = 0.5, \"delta\" = 0.0001)\nBayesLassoMfit &lt;- psbcSpeedUp::psbcSpeedUp(survObjM,\n  p = 50, q = 2, hyperpar = priorPara,\n  nIter = 100, burnin = 50, thin = 1, rw = FALSE, outFilePath = \"tmp\"\n)\nplot(BayesLassoMfit)\n\n\nRunning MCMC iterations ...\n[##################################################] 100%\nDONE, exiting! \n\n\n\nEstimates of regression coefficients by a penalized semiparametric Bayesian Cox model with Lasso prior and unpenalized covariates. Solid dots indicate the posterior mean over MCMC iterations (excluding burn-in period), and horizontal lines show the corresponding 95% credibility intervals.\n\n\n\nIn the R package psbcGroup (Lee, Chakraborty, and Sun 2021), function psbcEN() implements Bayesian Cox models with Elastic Net prior for feature selection with grouping effect of correlated features. Function psbcFL() implements Bayesian Cox models with fused Lasso prior.\n\n\nCode\n# Bayesian Cox model with Elastic Net prior\nset.seed(123)\n# set hyperparameters\n# Larger ratio r1/delta1 forces the posterior betas to be more concentrated at 0\n# Larger ratio r2/delta2 forces stronger grouping effect of covariates\npriorPara &lt;- list(\n  \"eta0\" = 1, \"kappa0\" = 1, \"c0\" = 2, \"r1\" = 0.1, \"r2\" = 1,\n  \"delta1\" = 0.1, \"delta2\" = 1, \"s\" = s, \"J\" = length(s)\n)\n# set MCMC parameters\nmcmcPara &lt;- list(\"numBeta\" = p, \"beta.prop.var\" = 1)\n# set initial values of hyperparameters\ninitial &lt;- list(\n  \"beta.ini\" = rep(0, p), \"lambda1Sq\" = 1, \"lambda2\" = 1, \"sigmaSq\" = runif(1, 0.1, 10),\n  \"tauSq\" = rexp(p, rate = 1 / 2), \"h\" = rgamma(priorPara$J, 1, 1)\n)\n# in real application, 'num.reps' should be large enough (e.g. 20000, 40000) and 'chain' to be &gt; 1\nBayesENfit &lt;- psbcEN(survObj, priorPara, initial, rw = FALSE, mcmcPara, \n                     num.reps = 100, thin = 1, chain = 1)\n# burn-in the first half MCMC iterations\nEN_beta_p &lt;- BayesENfit$beta.p[52:101, ]\ncolnames(EN_beta_p) &lt;- colnames(x)\npsbcSpeedUp:::plot.psbcSpeedUp(EN_beta_p)\n\n\n\n\n\nEstimates of regression coefficients by a penalized semiparametric Bayesian Cox model with Elastic Net prior. Solid dots indicate the posterior mean over MCMC iterations (excluding burn-in period), and horizontal lines show the corresponding 95% credibility intervals.\n\n\n\nA penalized semiparametric Bayesian Cox model with double exponential spike-and-slab prior is implemented in the R package BhGLM (Yi et al. 2019). Note that BhGLM provides frequentist confidence intervals of the posterior mode of the coefficients.\n\n\nCode\n# penalized semiparametric Bayesian Cox model with (double exponential) spike-and-slab prior\ny_surv &lt;- Surv(clin$time, clin$status)\nx_dataframe &lt;- as.data.frame(x)\nset.seed(123)\nBayesfit &lt;- BhGLM::bcoxph(y_surv ~ ., x_dataframe, prior = mde(0, 0.01, 0.8), control = coxph.control(iter.max = 200))\nBhGLM::plot.bh(Bayesfit, col.pts = c(\"red\", \"blue\"), main = \"Cox with mixture double exponential\\n\")\n\n\n\n\n\nCoefficient estimates of a penalized semiparametric Bayesian Cox model with (double exponential) spike-and-slab prior. Solid dots denote the posterior mode of the coefficients and lines denote the 95% confidence intervals. Red colored text on the right side mark the significant features with \\(p &lt; 0.05\\)."
  },
  {
    "objectID": "survomics.html#survival-model-validation",
    "href": "survomics.html#survival-model-validation",
    "title": "Supplemental information for ‘Tutorial on survival modeling with applications to omics data’",
    "section": "Survival model validation",
    "text": "Survival model validation\nThe ideal evaluation of a prognostic model is based on completely independent validation data, since high-dimensional survival models built on the training data can be overfitted. If there are no independent validation data, it is recommended to use resampling-based methods for estimating the uncertainty of the model’s prediction performance. This can be done for example by repeatedly splitting the dataset to training/validation sets and evaluating a model’s performance on the different validation sets using various evaluation metrics.\n\n\n\n\n\n\nModel validation\n\n\n\nTo validate a prediction model systematically, the predictive performance of the model is commonly addressed by\n\nDiscrimination: the ability of the model to distinguish between low and high risk patients\nCalibration: the agreement between the observed and predicted survival probabilities\nOverall performance: the distance between the observed and predicted survival probabilities\n\n\n\nThe performance metrics can be time-dependent or time-independent, with the time-dependent metrics being more informative in general compared to integrated measures (i.e. evaluated across many time points). For survival data, we can assess the discriminatory power of a model (i.e. how well does it ranks patients) or how well a model is calibrated (i.e. how closely the predicted survival probabilities agree numerically with the actual survival outcomes). For example, measures such as the receiver operating characteristic (ROC) curve, the (integrated) area under time-specific ROC curves (AUC, Heagerty and Zheng (2005)) and the concordance index (C-index, Harrell et al. (1982)) are measures of discrimination, while the right-censored logarithmic loss (RCLL, Avati et al. (2020)) and the well-known Brier score (Graf et al. 1999) are used to evaluate both discrimination and calibration performance.\n\nModel evaluation (classic)\n\n\n\n\n\n\nNote\n\n\n\n‘Classic’ here refers to the use of manual R code in combination with many separate R packages which have been routinely used in academia the latest 10+ years for evaluating survival models.\n\n\nTo evaluate the performance of a statistical model, we first split the data into training and validation data sets. For example, we can randomly split the 1047 BRCA patients from TCGA into \\(80\\%\\) as training set and \\(20\\%\\) as validation set.\n\n\nCode\nset.seed(123)\nn &lt;- nrow(x)\nidx &lt;- sample(1:n, n * 0.8, replace = FALSE)\nx_train &lt;- x[idx, ]\ny_train &lt;- y[idx, ]\nx_validate &lt;- x[-idx, ]\ny_validate &lt;- y[-idx, ]\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe \\(20\\%\\) split of a dataset is often not considered an independent dataset and resampling-based methods should be used in such cases to provide an unbiased estimate of the predictive accuracy of a prognostic model.\n\n\n\nDiscrimination metrics\n Goodness-of-fit \nThe simplest way to demonstrate the prognostic power of a survival model is to dichotomize the prognostic scores (i.e., linear predictor \\(lp\\) in the Cox model) by median value, and then to use a log-rank test to compare the survival curves of the patients in the two groups. We use the built model to predict the prognostic scores based on the \\(20\\%\\) validation data. The following code shows the goodness-of-fit of a Lasso Cox model with the BRCA patients survival and PAM50 mRNA-Seq data from TCGA.\n\n\nCode\n# train a Lasso Cox model, similarly for other Cox-type models\nset.seed(123)\ncvfit &lt;- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\npred_lp &lt;- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n\n# dichotomize by prognostic scores (linear predictor)  by median to divide the validation patients into two groups\ngroup_dichotomize &lt;- as.numeric(pred_lp &gt; median(pred_lp))\n\n# draw two survival curves based on KM estimation and compare them by a log-rank test\ndat_tmp &lt;- data.frame(time = y_validate[, 1], status = y_validate[, 2], group = group_dichotomize)\nsfit &lt;- survfit(Surv(time, status) ~ group, data = dat_tmp)\n\nggsurv &lt;- ggsurvplot(sfit,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\", legend = c(.2, .3),\n  legend.labs = c(\"Low risk\", \"High risk\"), legend.title = \"Dichotomized groups\",\n  risk.table.y.text.col = TRUE, risk.table.y.text = FALSE\n)\nggsurv$plot &lt;- ggsurv$plot +\n  annotate(\"text\", x = 2.6, y = .03, label = paste0(\"Log-rank test:\\n\", surv_pvalue(sfit)$pval.txt))\nggsurv$table &lt;- ggsurv$table + labs(y = \"Dichotomized\\n groups\")\nggsurv\n\n\n\n\n\nKaplan-Meier curves of the BRCA patients data dichotomized by the median of prognostic scores (calculated from the Lasso Cox model with patients’ survival and mRNA-Seq data) into two groups. The log-rank test is to compare the two survival distributions corresponding to the two groups of patients.\n\n\n\nThe prognostic scores can also be divided into three or more groups based on quantiles and the log-rank test can be used to compare the difference of multiple survival curves.\n\n\nCode\ngroup &lt;- pred_lp\ngroup[pred_lp &gt;= quantile(pred_lp, 2 / 3)] &lt;- 3\ngroup[pred_lp &gt;= quantile(pred_lp, 1 / 3) & pred_lp &lt; quantile(pred_lp, 2 / 3)] &lt;- 2\ngroup[pred_lp &lt; quantile(pred_lp, 1 / 3)] &lt;- 1\n\n# draw two survival curves based on KM estimation and compare them by a log-rank test\ndat_tmp &lt;- data.frame(time = y_validate[, 1], status = y_validate[, 2], group = group)\nsfit &lt;- survfit(Surv(time, status) ~ group, data = dat_tmp)\n\nggsurv &lt;- ggsurvplot(sfit,\n  conf.int = TRUE, risk.table = TRUE,\n  xlab = \"Time since diagnosis (year)\", legend = c(.2, .3),\n  legend.labs = c(\"Low risk\", \"Middle risk\", \"High risk\"), legend.title = \"Groups\",\n  risk.table.y.text.col = TRUE, risk.table.y.text = FALSE\n)\nggsurv$plot &lt;- ggsurv$plot +\n  annotate(\"text\", x = 3.5, y = .05, label = paste0(\"Log-rank test:\\n\", surv_pvalue(sfit)$pval.txt))\nggsurv\n\n\n\n\n\nKaplan-Meier curves of the BRCA patients data divided by 33% and 67% quantiles of prognostic scores (calculated from the Lasso Cox model with patients’ survival and mRNA-Seq data) into three groups. The log-rank test is to compare the two survival distributions corresponding to the three groups of patients.\n\n\n\n ROC curve \nThe R package risksetROC (Heagerty and Zheng 2005) can estimate a ROC curve at an evaluation time point. The following code draws a ROC curve at 5-years survival evaluation time point for the 20% TCGA validation data and based on a Lasso Cox model learned from the 80% training data.\n\n\nCode\nROC &lt;- risksetROC(\n  Stime = y_validate[, 1], status = y_validate[, 2],\n  marker = pred_lp, predict.time = 5, method = \"Cox\",\n  main = \"ROC Curve\", col = \"seagreen3\", type = \"s\",\n  lwd = 2, xlab = \"1 - Specificity\", ylab = \"Sensitivity\"\n)\ntext(0.7, 0.2, paste(\"AUC =\", round(ROC$AUC, 3)))\n\n\n\n\n\nROC curve estimated at 5-years survival evaluation time point for the 20% TCGA validation data and based on a Lasso Cox model learned from the 80% training data. The AUC value is the area under the ROC curve. The diagonal line represents the performance of a random prediction of the outcome event with AUC = 0.5.\n\n\n\n Time-dependent AUC \nBoth time-dependent and integrated AUCs can be estimated by the R package risksetROC. We demonstrate the calculation based on both training and validation data.\n\n\n\n\n\n\nSurvival prediction in Cox models\n\n\n\nA Cox proportional hazards model (and Lasso Cox as a consequence) is a semi-parametric model, which means that it does not produce survival distribution predictions by default. However, using the function risksetROC::CoxWeights() you can transform the cv.glmnet’s output linear predictors (lp) to survival distribution predictions. This transformation internally uses the Breslow estimator for the cumulative baseline hazard.\n\n\n\n\nCode\n# unique event times for patients in the training and validation data sets\nutimes_train &lt;- sort(unique(y_train[y_train[, 2] == 1, 1]))\nutimes_validate &lt;- sort(unique(y_validate[y_validate[, 2] == 1, 1]))\n\n# markers from the estimated linear predictors of a Lasso Cox model\npred_lp_train &lt;- predict(cvfit, newx = x_train, s = cvfit$lambda.min, type = \"link\")\npred_lp_validate &lt;- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n\n## compute time-dependent AUC\nAUC_train &lt;- rep(NA, length(utimes_train))\nAUC_validate &lt;- rep(NA, length(utimes_validate))\nfor (j in 1:length(utimes_train)) {\n  out &lt;- risksetROC::CoxWeights(\n    marker = pred_lp_train, Stime = y_train[, 1],\n    status = y_train[, 2], predict.time = utimes_train[j]\n  )\n  AUC_train[j] &lt;- out$AUC\n}\nfor (j in 1:length(utimes_validate)) {\n  out &lt;- risksetROC::CoxWeights(\n    marker = pred_lp_validate, Stime = y_validate[, 1],\n    status = y_validate[, 2], predict.time = utimes_validate[j]\n  )\n  AUC_validate[j] &lt;- out$AUC\n}\n\n# draw the time-dependent AUC from the training and validation data sets\ndat_AUC &lt;- data.frame(\n  tAUC = c(AUC_train, AUC_validate),\n  times = c(utimes_train, utimes_validate),\n  group = c(rep(\"AUC_train\", length(AUC_train)), rep(\"AUC_validate\", length(AUC_validate)))\n)\nggplot(dat_AUC, aes(times, tAUC, group = group, color = group)) +\n  xlab(\"Evaluation time points (year)\") +\n  ylab(\"AUC\") +\n  ylim(0.5, 1) +\n  geom_step(direction = \"vh\") +\n  theme(legend.position = c(0.7, 0.8), legend.title = element_blank())\n\n\n\n\n\nTime-dependent AUC based on a Lasso Cox model applied to the BRCA patients data from TCGA. The red line shows the Time-dependent AUC calculated from the 80% training data, and the green line shows the Time-dependent AUC calculated from the 20% validation data.\n\n\n\n Integrated AUC \nThe R package risksetROC (Heagerty and Zheng 2005) provides function IntegrateAUC() to estimate integrated AUC.\n\n\nCode\n# Before computing integrated AUC, first estimate survival probabilities at unique survival times\nsurv_prob_train &lt;- unique(survfit(Surv(y_train[, 1], y_train[, 2]) ~ 1)$surv)\nsurv_prob_validate &lt;- unique(survfit(Surv(y_validate[, 1], y_validate[, 2]) ~ 1)$surv)\n\n## integrated AUC (e.g. over tmax=10 years) to get concordance measure based on training data\n(iAUC_train &lt;- risksetROC::IntegrateAUC(AUC_train, utimes_train, surv_prob_train, tmax = 10))\n\n\n[1] 0.6279646\n\n\nCode\n## integrated AUC (e.g. over tmax=10 years) to get concordance measure based on validation data\n(iAUC_validate &lt;- risksetROC::IntegrateAUC(AUC_validate, utimes_validate, surv_prob_validate, tmax = 10))\n\n\n[1] 0.6318253\n Time-dependent C-index \nThe C-index is not proper for \\(t\\)-year predictions, see Blanche, Kattan, and Gerds (2019). Consider using time-dependent AUC or time-dependent Brier score instead. For a time-dependent discrimination index for survival data, see Antolini et al. (2005).\n C-index \nThe R package glmnet provides the function glmnet::Cindex() to estimate Harrell’s C-index from a “coxnet” object. The R package survAUC provides the function survAUC::UnoC() to estimated Uno’s C-index. See an example calculation for both C-indexes using a Lasso Cox model below.\n\n\nCode\nset.seed(123)\ncvfit &lt;- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\npred &lt;- predict(cvfit, newx = x_validate, type = \"link\", s = cvfit$lambda.min)\n# Harrell's C-index\n(Cindex_Harrell &lt;- Cindex(pred = pred[, 1], y = y_validate))\n\n\n[1] 0.7246466\n\n\nCode\n# Uno's C-index\n(Cindex_Uno &lt;- survAUC::UnoC(y_train, y_validate, pred))\n\n\n[1] 0.5772041\n\n\n\nCalibration metrics\nSee a calibration plot in the following section Graphical computation.\n\n\n\nOverall metrics\n Time-dependent Brier score \nThe R package riskRegression can assess the prediction error curves of survival models based on the time-dependent Brier score. Similar to the time-dependent AUC, one needs to first calculate the linear predictors (\\(lp\\)) from a frequentist or Bayesian Cox model, and then use survival::coxph() to regress the survival outcomes on the linear predictor, which is prepared as input of riskRegression::Score() to estimate the (time-dependent) Brier score. If the survival model was fitted via the R package psbcSpeedUp, the curve of the time-dependent Brier score can be drawn by using the function psbcSpeedUp::plotBrier().\n\n\nCode\n## time-dependent Brier score\n\n# use the (x_train, y_train) 80% samples for training\n# and the (x_validate, y_validate) 20% samples for testing\n\ny_train_surv &lt;- Surv(y_train[, \"time\"], y_train[, \"status\"])\ny_validate_surv &lt;- Surv(y_validate[, \"time\"], y_validate[, \"status\"])\nset.seed(123)\ncvfit &lt;- cv.glmnet(x_train, y_train_surv, family = \"cox\", nfolds = 5, penalty.factor = pf)\nlp_train &lt;- predict(cvfit, newx = x_train, s = cvfit$lambda.min, type = \"link\")\nlp_validate &lt;- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n\n# prepare data format suited for function Score() from the riskRegression package\ndata_train &lt;- data.frame(time = y_train[, \"time\"], status = y_train[, \"status\"], lp = as.vector(lp_train))\ndata_validate &lt;- data.frame(time = y_validate[, \"time\"], status = y_validate[, \"status\"], lp = as.vector(lp_validate))\nlasso_train &lt;- coxph(Surv(time, status) ~ lp, data = data_train, y = TRUE, x = TRUE)\nlasso_validate &lt;- coxph(Surv(time, status) ~ lp, data = data_validate, y = TRUE, x = TRUE)\n\n# calculate Brier scores based on both training and validation data\nBrier_train &lt;- riskRegression::Score(list(\"Brier_train\" = lasso_train), formula = Surv(time, status) ~ 1, data = data_train, conf.int = FALSE, metrics = \"brier\", summary = \"ibs\", times = sort(unique(data_train$time)))$Brier$score\nBrier_validate &lt;- riskRegression::Score(list(\"Brier_validate\" = lasso_validate), formula = Surv(time, status) ~ 1, data = data_validate, conf.int = FALSE, metrics = \"brier\", summary = \"ibs\", times = sort(unique(data_validate$time)))$Brier$score\nBrier_score &lt;- rbind(Brier_train, Brier_validate)\nBrier_score &lt;- Brier_score[Brier_score$model != \"Null model\", ]\n\nggplot(Brier_score, aes(times, Brier, group = model, color = model)) +\n  xlab(\"Evaluation time points (year)\") +\n  ylab(\"Brier score\") +\n  geom_step(direction = \"vh\") +\n  theme(legend.position = c(0.15, 0.88), legend.title = element_blank())\n\n\n\n\n\nTime-dependent Brier score based on a Lasso Cox model applied to the BRCA patients data from TCGA. The red line shows the Time-dependent Brier score calculated from the 80% training data, and the green line shows the Time-dependent Brier score calculated from the 20% validation data.\n\n\n\n Integrated Brier score (IBS) \nThe function riskRegression::Score() also summarizes IBS when specifying argument summary = \"ibs\". We can extract the IBS corresponding to the largest evaluation time point.\n\n\nCode\nBrier_validate_ibs &lt;- Brier_validate[Brier_validate$model == \"Brier_validate\", ]\nBrier_validate_ibs$IBS[which.max(Brier_validate_ibs$times)]\n\n\n[1] 0.1721158\n\n\n\nUncertainty Quantification\n\n\n\n\n\n\nImportant\n\n\n\nIt is recommended to use resampling-based methods for estimating the uncertainty of the model’s performance, if there are no independent validation data for model evaluation. This can be done for example by repeatedly splitting the dataset to training/validation sets and evaluating a model’s performance on the different validation sets using various discrimination or calibration metrics.\n\n\nWe demonstrate how to randomly split the data, e.g. \\(100\\) times, train a Lasso Cox model and estimate the integrated AUC based on the validation data in each replication. For other Cox-type models, we can just replace the model fitting part cv.glmnet() (and predict()) in the for loop below. However, most of the Bayesian Cox models introduced previously are computationally time-consuming when randomly splitting the data many times.\n\n\nCode\n# split the data 100 times\nset.seed(123)\nk &lt;- 100\niAUC &lt;- rep(NA, k)\nfor (i in 1:k) {\n  idx &lt;- sample(1:n, n * 0.8, replace = FALSE)\n  x_train &lt;- x[idx, ]\n  y_train &lt;- y[idx, ]\n  x_validate &lt;- x[-idx, ]\n  y_validate &lt;- y[-idx, ]\n  cvfit &lt;- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  pred_lp &lt;- predict(cvfit, newx = x_validate, s = cvfit$lambda.min, type = \"link\")\n  utimes &lt;- sort(unique(y_validate[y_validate[, 2] == 1, 1]))\n  AUC &lt;- rep(NA, length(utimes))\n  for (j in 1:length(utimes)) {\n    out &lt;- CoxWeights(marker = pred_lp, Stime = y_validate[, 1], status = y_validate[, 2], predict.time = utimes[j])\n    AUC[j] &lt;- out$AUC\n  }\n  surv_prob &lt;- unique(survfit(Surv(y_validate[, 1], y_validate[, 2]) ~ 1)$surv)\n  iAUC[i] &lt;- IntegrateAUC(AUC, utimes, surv_prob, tmax = 10)\n}\ndat_tmp &lt;- data.frame(x = \"Lasso Cox\", y = iAUC)\n\nset.seed(123)\nggplot(dat_tmp, aes(x, y)) +\n  geom_boxplot() +\n  ylim(0.5, 1) +\n  xlab(\"\") +\n  ylab(\"Integrated AUC\") +\n  geom_jitter(color = \"blue\", size = 0.5, alpha = 0.5)\n\n\n\n\n\nIntegrated AUC based on randomly split validation data 100 times. The blue dots are the 100 values of integrated AUC.\n\n\n\nSimilar to obtaining uncertainty of the integrated AUC, we can also estimate the uncertainty of the C-index for evaluating the global performance of our model’s discrimination.\n\n\nCode\n# split the data 100 times\nset.seed(123)\nk &lt;- 100\nCindex_all &lt;- data.frame(Harrell = rep(NA, k), Uno = rep(NA, k))\nfor (i in 1:k) {\n  idx &lt;- sample(1:n, n * 0.8, replace = FALSE)\n  x_train &lt;- x[idx, ]\n  y_train &lt;- y[idx, ]\n  x_validate &lt;- x[-idx, ]\n  y_validate &lt;- y[-idx, ]\n  cvfit &lt;- cv.glmnet(x_train, y_train, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  pred &lt;- predict(cvfit, newx = x_validate, type = \"response\", s = cvfit$lambda.min)\n  Cindex_all$Harrell[i] &lt;- mean(apply(pred, 2, Cindex, y = y_validate))\n  Cindex_all$Uno[i] &lt;- UnoC(y_train, y_validate, pred)\n}\ndat_tmp &lt;- data.frame(x = rep(c(\"Harrell\", \"Uno\"), each = k), y = unlist(Cindex_all))\n\nset.seed(123)\nggplot(dat_tmp, aes(x, y, col = x)) +\n  geom_boxplot() +\n  geom_jitter(size = 0.5, alpha = 0.5) +\n  ylim(0, 1) +\n  xlab(\"\") +\n  ylab(\"C-index\") +\n  theme(legend.position = \"none\")\n\n\n\n\n\nC-index (Harrell’s and Uno’s) based on randomly split validation data 100 times.\n\n\n\nThe R package c060 (Sill et al. 2014) includes wrapper functions for the glmnet algorithm and implements resampling-based methods (e.g. cross-validation and bootstrap - with and without replacement) based on the peperr package to calculate the time-dependent Brier score. c060 extends peperr package to allow mandatory features without penalization. Binder and Schumacher (2008) recommends to draw bootstrap samples without replacement (i.e. subsampling), because bootstrap samples with replacement often result in too complex models in high-dimensional settings. To use resampling by CV properly for survival data, see R. M. Simon et al. (2011). Note that resampling-based methods here are similar to splitting \\(80\\%/20\\%\\) the data many times which allows us to quantify the uncertainty of the time-dependent Brier score.\n\n\nCode\n## time-dependent Brier score by subsampling from the whole data\nset.seed(123)\npeperr_object &lt;- peperr::peperr(\n  response = y_surv, x = x, fit.fun = fit.glmnet,\n  args.fit = list(family = \"cox\", penalty.factor = pf),\n  complexity = complexity.glmnet,\n  args.complexity = list(family = \"cox\", nfolds = 5, penalty.factor = pf),\n  indices = resample.indices(n = n, method = \"sub632\", sample.n = 100)\n)\nc060::Plot.peperr.curves(peperr_object)\n\n\n\n\n\nResampling-based prediction error curves (time-dependent Brier score) a the Lasso Cox model applied to the BRCA data set from TCGA. The gray area indicates the pointwise 2.5% and 97.5% quantiles of the 100 out-of-bag bootstrap samples. The other lines show the prediction error curves of the null model (estimated by the Kaplan-Meier estimator without covariate information), the full apparent error estimates (i.e., the errors as estimated when applying the model to the entire training data set), and the .632+ bootstrap error estimates.\n\n\n\n\n\nFeature stability analysis\nTo identify stable omics features, a straightforward way is to find the overlapped omics features with nonzero coefficients among different data subsets (e.g. CV folds or resamples). The following code summarizes the Lasso Cox selected omics features which were identified at least \\(2\\) or \\(5\\) out of \\(10\\) resamples. Similarly, this approach can be applied to other Lasso-type or Bayesian Cox models that perform feature selection for identifying stable selected features.\n\n\nCode\n# specify the number of resamples k\nk &lt;- 10\nbeta_all &lt;- matrix(nrow = ncol(x), ncol = k)\nset.seed(123)\nfor (j in 1:k) {\n  resample_id &lt;- sample(1:nrow(y), nrow(y), replace = TRUE)\n  resample_x &lt;- x[resample_id, ]\n  resample_y &lt;- y[resample_id, ]\n  cvfit &lt;- cv.glmnet(resample_x, resample_y, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  beta_all[, j] &lt;- as.vector(coef(cvfit, s = cvfit$lambda.min))\n}\n\n(stable_features &lt;- colnames(x)[rowSums(beta_all != 0) &gt;= 2])\n\n\n [1] \"age\"       \"ethnicity\" \"ANLN\"      \"UBE2T\"     \"NDC80\"     \"PGR\"       \"ORC6\"     \n [8] \"ESR1\"      \"PHGDH\"     \"MMP11\"     \"SFRP1\"     \"CCNE1\"     \"BLVRA\"     \"BAG1\"     \n[15] \"MLPH\"      \"CENPF\"     \"KRT17\"     \"FOXA1\"     \"ACTR3B\"    \"CCNB1\"     \"MDM2\"     \n[22] \"MYC\"       \"CEP55\"     \"SLC39A6\"   \"GRB7\"      \"NUF2\"      \"EGFR\"      \"MKI67\"    \n[29] \"TMEM45B\"   \"FGFR4\"     \"MELK\"      \"NAT1\"      \"CXXC5\"     \"BCL2\"      \"GPR160\"   \n[36] \"TYMS\"      \"KRT5\"      \"MAPT\"      \"MIA\"\n\n\nCode\n(stable_features &lt;- colnames(x)[rowSums(beta_all != 0) &gt;= 5])\n\n\n [1] \"age\"       \"ethnicity\" \"ANLN\"      \"ORC6\"      \"MMP11\"     \"BLVRA\"     \"BAG1\"     \n [8] \"CCNB1\"     \"EGFR\"      \"TMEM45B\"   \"BCL2\"      \"TYMS\"      \"KRT5\"      \"MIA\"\nAlternatively for a Bayesian Cox model, its median probability model (MPM) can be obtained based on the coefficient estimates over MCMC iterations. The following code shows how to obtain the MPM’s coefficients of the penalized semiparametric Bayesian Cox model with Elastic Net prior run previously.\n\n\nCode\ngammas &lt;- colMeans(matrix(as.numeric(EN_beta_p != 0), ncol = ncol(EN_beta_p)))\nbeta_MPM &lt;- (gammas &gt;= 0.5) * colMeans(EN_beta_p) / gammas\nbeta_MPM[is.na(beta_MPM)] &lt;- 0\nbeta_MPM\n\n\n          age     ethnicity          ANLN         FOXC1          CDH3         UBE2T \n 1.305162e-02  5.348458e-03 -1.299443e-03 -1.857811e-02 -6.123574e-03 -5.467111e-03 \n        NDC80           PGR         BIRC5          ORC6          ESR1         PHGDH \n-6.652927e-03 -2.101243e-06 -1.640386e-02 -1.237153e-02 -1.077863e-02  2.483990e-02 \n         CDC6         MMP11         MYBL2         SFRP1         CCNE1         BLVRA \n-9.079708e-03 -1.588726e-02  5.225344e-03 -1.383981e-02 -3.181265e-03 -2.632373e-02 \n         BAG1          MLPH         CDC20         CENPF         KRT17         FOXA1 \n-3.913529e-02 -1.435805e-02 -2.027232e-02 -2.476495e-02 -2.871143e-02 -3.017213e-03 \n       ACTR3B         CCNB1          MDM2           MYC         CEP55       SLC39A6 \n-2.504869e-03 -1.346817e-03 -2.156041e-02  1.431062e-02  1.421036e-02 -1.150196e-02 \n        ERBB2          GRB7         KIF2C          NUF2          EGFR         MKI67 \n-6.347367e-03 -1.008689e-02  6.033792e-03 -2.405689e-03 -1.964927e-02  1.956661e-02 \n      TMEM45B         FGFR4         PTTG1          MELK          NAT1         CXXC5 \n 2.736216e-02  1.842323e-03 -5.651905e-03  2.894074e-02 -2.126163e-02  2.571472e-02 \n         BCL2          RRM2        GPR160          EXO1         UBE2C          TYMS \n-5.140894e-03  2.881004e-02 -3.927705e-02 -1.710419e-02 -1.343832e-02 -1.884342e-02 \n         KRT5         KRT14          MAPT           MIA \n-2.180294e-02 -1.386489e-03 -2.587557e-02 -1.033317e-02\n\n\n\nGraphical representation\nAfter identifying stable omics features predictive of survival outcomes, we can draw a nomogram to allows the graphical calculation of survival probabilities and report a calibration plot for practitioners.\n Nomogram \nWe demonstrate a nomogram using the stable selected features from TCGA breast cancer data preprocessed previously. The R package regplot draws an enhanced regression nomogram based on the rms package.\n\n\nCode\n# remove patients without reporting ethnicity\nyy &lt;- y[x[, 2] != 3, ]\nxx &lt;- x[x[, 2] != 3, ]\n# specify the number of resamples k\nk &lt;- 10\nbeta_all &lt;- matrix(nrow = ncol(xx), ncol = k)\nset.seed(123)\nfor (j in 1:k) {\n  resample_id &lt;- sample(1:nrow(yy), nrow(yy), replace = TRUE)\n  resample_x &lt;- xx[resample_id, ]\n  resample_y &lt;- yy[resample_id, ]\n  cvfit &lt;- cv.glmnet(resample_x, resample_y, family = \"cox\", nfolds = 5, penalty.factor = pf)\n  beta_all[, j] &lt;- as.vector(coef(cvfit, s = cvfit$lambda.min))\n}\n\n# identify features at least 80% frequently selected\nx_stable &lt;- data.frame(xx[, rowSums(beta_all != 0) &gt;= k * 0.8])\nx_stable$ethnicity &lt;- factor(x_stable$ethnicity)\nlevels(x_stable$ethnicity) &lt;- c(\"Hispanic/latino\", \"Not hispanic/latino\")\n\ndata_tmp &lt;- data.frame(times = yy[, \"time\"], status = yy[, \"status\"], x_stable)\nf &lt;- cph(\n  formula = Surv(times, status) ~ age + ethnicity + ANLN + BLVRA + EGFR,\n  data = data_tmp, x = TRUE, y = TRUE, surv = TRUE\n)\nddist &lt;- datadist(data_tmp)\noldoption &lt;- options(datadist = \"ddist\")\nsurv &lt;- Survival(f)\nnom &lt;- nomogram(f,\n  fun = list(function(x) surv(1, x), function(x) surv(3, x), function(x) surv(5, x)),\n  funlabel = c(\n    \"1-Year Survival Probability\",\n    \"3-Year Survival Probability\",\n    \"5-Year Survival Probability\"\n  ),\n  lp = FALSE\n)\nregplot::regplot(f,\n  observation = data_tmp[1, ], failtime = c(1, 3, 5), title = \"\",\n  prfail = FALSE, points = TRUE, showP = FALSE, subticks = TRUE\n)\n\n\n\n\n\nNomogram developed to estimate the overall survival probability for TCGA’s BRAC patients based on demographic and Lasso Cox selected mRNA features. The red coloured symbols represent one patient’s information and predicted probabilities of 1-year, 3-year and 5-year survival.\n\n\n\n Calibration plot \nA calibration plot is a straightforward visualization to show the prediction ability of the nomogram, i.e., the agreement between predicted survival probabilities from the final model and the KM estimated survival probabilities in different percentiles of the predicted values at a time point of interest. We demonstrate below calibration plots based on training and validation data sets, respectively.\n\n\nCode\n# Calibration at 5-year time-point\n\n# prepare suitable data format for calibration plot\nset.seed(123)\ntrain_id &lt;- sample(1:nrow(yy), nrow(yy) * 0.8, replace = FALSE)\ndata_train &lt;- data_tmp[train_id, ]\ndata_validate &lt;- data_tmp[-train_id, ]\n\nddist &lt;- datadist(data_train)\noptions(datadist = \"ddist\")\nf_train &lt;- cph(\n  formula = Surv(times, status) ~ age + ethnicity + ANLN + BLVRA + EGFR,\n  data = data_train, x = TRUE, y = TRUE, surv = TRUE, time.inc = 5\n)\nf_validate &lt;- update(f_train, data = data_validate)\ncal_train &lt;- calibrate(f_train, u = 5, cmethod = \"KM\", m = nrow(data_train) / 4, B = 200)\ncal_validate &lt;- calibrate(f_validate, u = 5, cmethod = \"KM\", m = nrow(data_validate) / 4, B = 200)\n\nlayout(matrix(1:2, nrow = 1))\nplot(cal_train,\n  lwd = 2, lty = 1, errbar.col = \"seagreen3\",\n  xlab = \"Predicted survival probability\", ylab = \"Actual survival probability\",\n  xlim = c(0, 1), ylim = c(0, 1), col = \"seagreen3\", subtitles = FALSE\n)\ntitle(main = \"Calibration on training data\")\n\nplot(cal_validate,\n  lwd = 2, lty = 1, errbar.col = \"seagreen3\",\n  xlab = \"Predicted survival probability\", ylab = \"Actual survival probability\",\n  xlim = c(0, 1), ylim = c(0, 1), col = \"seagreen3\", subtitles = FALSE\n)\ntitle(main = \"Calibration on validation data\")\n\n\n\n\n\nNomogram model calibration curves for TCGA’s BRAC patients at 5-year evaluation time-point.\n\n\n\n\n\n\nModel evaluation (mlr3)\n\n\n\n\n\n\nWe will use the mlr3 ML framework and the mlr3proba R library to:\n\n\n\n\nCreate a survival task from a dataset and split it to training and test (validation) sets\nDefine a Lasso Cox model that can output both linear predictors and survival distribution predictions and train/tune it on the training set\nMake predictions using the trained Lasso Cox model on the separate test set\nMeasure the performance of our model (discrimination and calibration) using several evaluation metrics\nUsing resampling techniques, we will assess our model’s capacity for generalization (prediction on unseen data) and the stability of the model’s selected features\n\n\n\nFor the rest of the analysis, we will borrow the terminology from the mlr3 ecosystem of machine learning packages (e.g. task is a dataset, learner is a model, etc.). See mlr3 book for more details.\nFirst, we load the necessary mlr3 libraries (Lang et al. 2019; Sonabend et al. 2021) and some other useful ones:\n\n\nCode\nlibrary(\"mlr3verse\") # mlr3, mlr3pipeplines, mlr3learners, mlr3tuning, paradox, etc.\nlibrary(\"mlr3proba\") # probabilistic learning and survival analysis\nlibrary(\"mlr3extralearners\") # for lrn('surv.glmnet')\n\n\n\n\nWorkflow\nWe construct an mlr3 survival task (TCGA BRCA dataset essentially, with normalized PAM50 gene expression features and two clinical/demographic variables) and split it into training and test sets (\\(80\\%/20\\%\\)):\n\n\nCode\n# From 'Penalized Cox models' section:\n# x =&gt; gene expression matrix (50 PAM50 genes) + 2 clinical variables\n# y =&gt; (time, status) target matrix\n\ndata &lt;- cbind.data.frame(x, y)\n# data = readRDS(file = 'data.rds')\ntask &lt;- mlr3proba::as_task_surv(\n  x = data,\n  time = \"time\", event = \"status\", id = \"BRCA-TCGA\"\n)\ntask # see useful info about the dataset (#features, #samples, target variables)\n\n# split to train and test sets\nset.seed(42)\nsplit &lt;- mlr3::partition(task, ratio = 0.8)\n# split$train # train indices\n# split$test # test indices\n\n\n&lt;TaskSurv:BRCA-TCGA&gt; (1047 x 54)\n* Target: time, status\n* Properties: -\n* Features (52):\n  - dbl (52): ACTR3B, ANLN, BAG1, BCL2, BIRC5, BLVRA, CCNB1, CCNE1, CDC20, CDC6, CDH3,\n    CENPF, CEP55, CXXC5, EGFR, ERBB2, ESR1, EXO1, FGFR4, FOXA1, FOXC1, GPR160, GRB7,\n    KIF2C, KRT14, KRT17, KRT5, MAPT, MDM2, MELK, MIA, MKI67, MLPH, MMP11, MYBL2, MYC,\n    NAT1, NDC80, NUF2, ORC6, PGR, PHGDH, PTTG1, RRM2, SFRP1, SLC39A6, TMEM45B, TYMS,\n    UBE2C, UBE2T, age, ethnicity\nWe create a Lasso Cox mlr3 learner (a wrapper around the glmnet::cv.glmnet() function with the capacity to provide survival predictions), where we specify the two clinical variables to be mandatory (i.e. no penalization) and the \\(s\\) value (\\(\\lambda\\) parameter used for prediction) equal to lambda.min:\n\n\nCode\n# tail(task$feature_names) # age, ethnicity are the 2 last features\npf &lt;- c(rep(1, length(task$feature_names) - 2), rep(0, 2))\n\n# define model\ncoxlasso &lt;- lrn(\"surv.cv_glmnet\",\n  alpha = 1, nfolds = 5, s = \"lambda.min\",\n  penalty.factor = pf\n)\n# coxlasso # see learner details\n# coxlasso$help() # see learner documentation\n\n\n\n\n\n\n\n\nNote\n\n\n\nA Cox proportional hazards model (and Lasso Cox as a consequence) is a semi-parametric model, which means that it does not produce survival distribution predictions by default. The mlr3 glmnet survival learner uses internally the function glmnet::survfit.coxnet() to transform the cv.glmnet’s linear predictors (lp) to survival distribution predictions. This transformation uses the Breslow estimator for the cumulative baseline hazard (see stype parameter in survival::survfit.coxph()).\n\n\n\nTrain the Lasso Cox model:\n\n\nCode\nset.seed(3)\ncoxlasso$train(task, row_ids = split$train)\n# view `cv.glmnet` fit\ncoxlasso$model$model\n\n\nCall:  (if (cv) glmnet::cv.glmnet else glmnet::glmnet)(x = data, y = target,      nfolds = 5L, alpha = 1, penalty.factor = c(1, 1,..., 1, 0, 0), family = \"cox\")\n\nMeasure: Partial Likelihood Deviance \n\n     Lambda Index Measure     SE Nonzero\nmin 0.01082    14   12.31 0.2743      15\n1se 0.03626     1   12.35 0.2564       2\nGet the survival distribution predictions (\\(distr\\)) along with the linear predictors (\\(lp\\)):\n\n\nCode\npred &lt;- coxlasso$predict(task, row_ids = split$test)\nhead(as.data.table(pred))\n\n\n   row_ids      time status     crank        lp     distr\n1:       5 0.9527721  FALSE -2.346574 -2.346574 &lt;list[1]&gt;\n2:       6 4.0438056  FALSE -2.806708 -2.806708 &lt;list[1]&gt;\n3:      15 1.7385352  FALSE -1.845042 -1.845042 &lt;list[1]&gt;\n4:      45 4.5804244  FALSE -1.715041 -1.715041 &lt;list[1]&gt;\n5:      50 5.1279945  FALSE -2.790122 -2.790122 &lt;list[1]&gt;\n6:      54 6.6858316  FALSE -2.466360 -2.466360 &lt;list[1]&gt;\nSo for every patient in the test set, the Lasso Cox model prediction is a linear predictor of the form \\(lp = \\hat{\\beta} X_{new}\\). \\(crank\\) stands for continuous ranking score and it’s the same as \\(lp\\) for the Lasso Cox model. The \\(distr\\) predictions are the per-patient survival distribution predictions, implemented by the R package distr6 which the mlr3proba imports. See respective documentation on the different prediction types supported.\nAn example of using the distr predictions would be to request for the survival probability at e.g. \\(1,5,10,20\\) years for the first two patients in the test set:\n\n\nCode\ntimes &lt;- c(1, 5, 10, 20)\nids &lt;- c(1,2)\npred$distr[ids]$survival(times)\n\n# same logic for the cumulative hazard\n# pred$distr[ids]$cumHazard(times)\n\n\n        [,1]      [,2]\n1  0.9889822 0.9930314\n5  0.8711262 0.9165987\n10 0.6708848 0.7772850\n20 0.4540815 0.6075516\n\n\n\nDiscrimination metrics\nWe want to test our Lasso Cox model and see how well it was able to discriminate the patients in the test set. For this we can use the \\(lp\\) predictions of Lasso Cox model and metrics such as the (time-dependent) C-index and (time-dependent) AUC. \n Harrell’s C-index (Harrell et al. 1982): \n\n\nCode\nharrell_c &lt;- msr(\"surv.cindex\")\nharrell_c$id &lt;- \"surv.cindex.harrell\"\n\n# harrell_c # get some details about the measure\n# harrell_c$minimize # FALSE =&gt; higher C-index is better\n# harrell_c$range # [0, 1] =&gt; [min, max]\n# harrell_c$predict_type # uses the $crank$ predictions (equal to $lp$ for Lasso Cox\n\npred$score(harrell_c)\n\n\nsurv.cindex.harrell \n          0.6224306\n\n Uno’s C-index (Uno et al. 2011): (across all time points of the test set): \n\n\nCode\nuno_c &lt;- msr(\"surv.cindex\", weight_meth = \"G2\")\nuno_c$id &lt;- \"surv.cindex.uno\"\n\n# Uno's C needs the train data\npred$score(uno_c, task = task, train_set = split$train)\n\n\nsurv.cindex.uno \n      0.5932426\n\n Uno’s Integrated AUC (Uno et al. 2007) (across all time points of the test set): \n\n\nCode\nuno_iauc &lt;- msr(\"surv.uno_auc\")\nuno_iauc$id &lt;- \"surv.uno_iauc\"\n# uno_iauc$param_set$values$integrated # integrated = TRUE by default\n# sort(unique(pred$truth[,1])) # time points used\n\n# uno_iauc$properties # needs the train data\npred$score(uno_iauc, task = task, train_set = split$train)\n\n\nsurv.uno_iauc \n    0.6585791\n\n Uno’s AUC at a specific time point, e.g. \\(10\\) years: \n\n\nCode\nuno_auc &lt;- msr(\"surv.uno_auc\", integrated = FALSE, times = 10)\nuno_auc$id &lt;- \"surv.uno_auc.10\"\n\n# needs the train data\npred$score(uno_auc, task = task, train_set = split$train)\n\n\nsurv.uno_auc.10 \n      0.667014\n\n\n\nCalibration metrics\nWe want to test how well our Lasso Cox model was calibrated. Andres et al. (2018) and Haider et al. (2020) suggested the distributional (D)-calibration accounting survival probabilities across all times. This can be useful when assessing the entire post-treatment survival prognosis, for example, assessing the post liver transplantation survival utility in Andres et al. (2018).\n D-calibration \n\n\nCode\ndcal &lt;- msr(\"surv.dcalib\")\npred$score(dcal)\n\n\nsurv.dcalib\n   0.8342449\n\n\n\nOverall metrics\nUsually we derive an estimation of the error between the survival distributions (\\(distr\\) predictions) of the patients in the test set and their actual survival outcomes (corresponding to the survival task’s time and status variables). The most frequently used metric is the Brier Score (Graf et al. 1999): \n Integrated Brier Score (IBS) (across all time points of the test set): \n\n\nCode\nibrier &lt;- msr(\"surv.brier\", proper = TRUE)\n# ibrier$help() # see documentation\n# ibrier$predict_type # uses the `distr` predictions\n\n# better to use the train data for the Kaplan-Meier estimation of the censoring distribution, but can use the test set as well\npred$score(ibrier, task = task, train_set = split$train)\n\n\nsurv.graf \n0.1157316\nWe can also get the standard error of IBS (the above result is the mean across all the test set’s patients) as follows:\n\n\nCode\nibrier_se &lt;- msr(\"surv.brier\", proper = TRUE, se = TRUE)\npred$score(ibrier_se, task = task, train_set = split$train)\n\n\n surv.graf \n0.01795861\n\n Brier Score at a specific time point, e.g. \\(10\\) years: \n\n\nCode\nbrier10 &lt;- msr(\"surv.brier\", proper = TRUE, integrated = FALSE, times = 10)\nbrier10$id &lt;- \"surv.graf.10\"\n\n# better to use the train data for the Kaplan-Meier estimation of the censoring distribution, but can use the test set as well\npred$score(brier10, task = task, train_set = split$train)\n\n\nsurv.graf.10 \n   0.1755639\n\n Right-censored Logarithmic Loss score (RCLL) (Avati et al. 2020; Sonabend 2022): \n\n\nCode\nrcll &lt;- msr(\"surv.rcll\")\npred$score(rcll)\n\n\nsurv.rcll \n 4.781513\n\n\n\n\n\n\n\nNote\n\n\n\nView all evaluation metrics for survival data implemented in mlr3proba here\n\n\n\n\n\nUncertainty Quantification\nSimilar procedure as followed in a previous section.\nWe will perform a stratified split of the BRCA-TCGA survival task to training and test sets (with a \\(80\\%/20\\%\\) ratio as before). Stratification on the censoring indicator status is important because we want our training and test sets to have the same censoring distribution as the initial dataset. Thus we can avoid measuring performance on test sets with severely different censoring distributions that might influence the performance scores.\nStratify survival task by status:\n\n\nCode\ncoxlasso$reset() # un-train model\n\ntask$col_roles$stratum &lt;- \"status\"\n# task\n\n\nNext, we define the type of resampling (?mlr_resamplings_subsampling), train the Lasso Cox model on all training sets (\\(100\\)) and store the fitted models for feature selection and evaluation:\n\n\nCode\n# 100 times train/test split (80% for training, 20% for validation)\nsubsampling &lt;- rsmp(\"subsampling\", repeats = 100, ratio = 0.8)\n\nset.seed(42)\nrr &lt;- mlr3::resample(\n  task = task, learner = coxlasso,\n  resampling = subsampling, store_models = TRUE, store_backends = TRUE\n)\n\n\nWe can use all the aforementioned evaluation metrics to measure the performance of the Lasso Cox models on the \\(100\\) different test sets. Note that if a metric needs the training dataset it is automatically provided by the ResampleResult object (rr):\n\n\nCode\nmeasures &lt;- list(harrell_c, uno_c, uno_iauc, uno_auc, ibrier, brier10, rcll, dcal)\n\nres &lt;- rr$score(measures = measures)\nhead(res)\n\n\n    task_id learner_id resampling_id iteration surv.cindex.harrell surv.cindex.uno \n1: BRCA-TCGA  Lasso Cox   subsampling         1           0.5679167       0.6090304\n2: BRCA-TCGA  Lasso Cox   subsampling         2           0.5422131       0.4884603\n3: BRCA-TCGA  Lasso Cox   subsampling         3           0.7604049       0.5740556\n4: BRCA-TCGA  Lasso Cox   subsampling         4           0.6610169       0.5277736\n5: BRCA-TCGA  Lasso Cox   subsampling         5           0.5800073       0.5655076\n6: BRCA-TCGA  Lasso Cox   subsampling         6           0.5427837       0.6975740\n  surv.uno_iauc surv.uno_auc.10 surv.graf surv.graf.10 surv.rcll surv.dcalib\n1:     0.6628350       0.4719335 0.1736450    0.2582078  4.914347   0.5890987\n2:     0.4023684       0.5652588 0.1855191    0.2185453  4.914264   0.6552037\n3:     0.5941948       0.5235439 0.1014616    0.1329289  5.041827   0.8480314\n4:     0.5360690       0.5110032 0.1122070    0.1157937  5.045144   0.4981035\n5:     0.6160743       0.5388393 0.1099091    0.1940644  5.060352   0.2036418\n6:     0.6494779       0.6400328 0.1377626    0.2445218  5.059521   0.5175357\nHidden columns: task, learner, resampling, prediction\nWe extract and visualize the discrimination and calibration (resampled) performance of our Lasso Cox model using several evaluation metrics:\n\n\nCode\nset.seed(42)\n\n# C-indexes, AUCs (integrated and at t = 10 years)\nres[, .(surv.cindex.harrell, surv.cindex.uno, surv.uno_iauc, surv.uno_auc.10)] %&gt;%\n  tidyr::pivot_longer(\n    cols = tidyselect::everything(),\n    names_to = \"Measure\", values_to = \"Value\"\n  ) %&gt;%\n  mutate(Measure = case_when(\n    Measure == \"surv.cindex.harrell\" ~ \"Harrell's C-index\",\n    Measure == \"surv.cindex.uno\" ~ \"Uno's C-index\",\n    Measure == \"surv.uno_iauc\" ~ \"Uno's Integrated AUC\",\n    Measure == \"surv.uno_auc.10\" ~ \"Uno's AUC (t = 10 years)\",\n  )) %&gt;%\n  mutate(Measure = factor(Measure, levels = c(\n    \"Harrell's C-index\",\n    \"Uno's C-index\",\n    \"Uno's Integrated AUC\",\n    \"Uno's AUC (t = 10 years)\"\n  ))) %&gt;%\n  ggplot(aes(x = Measure, y = Value, fill = Measure)) +\n  geom_boxplot() +\n  ylim(c(0.2, 0.8)) +\n  geom_hline(yintercept = 0.5, color = \"red\", linetype = \"dashed\") +\n  theme_bw(base_size = 14) +\n  labs(title = \"Discrimination Measures\") +\n  theme(axis.text.x = element_blank())\n\n\n\n\n\nDiscrimination performance of Lasso Cox on the TCGA-BRCA dataset (expression data of the PAM50 genes and the variables age and ethnicity). Performance metrics used are Harrell’s C-index, Uno’s C-index, Uno’s Integrated AUC and Uno’s AUC at 10 years. The dataset was split to training/validation sets 100 times to allow for the quantification of uncertainty in the different performance estimates.\n\n\n\n\nCode\n# different scales for each measure, so we separate the plots\nset.seed(42)\n\n# Integrated Brier Score and Brier Score at t = 10 years\nres[, .(surv.graf, surv.graf.10)] %&gt;%\n  tidyr::pivot_longer(\n    cols = tidyselect::everything(),\n    names_to = \"Measure\", values_to = \"Value\"\n  ) %&gt;%\n  mutate(Measure = case_when(\n    Measure == \"surv.graf\" ~ \"IBS\",\n    Measure == \"surv.graf.10\" ~ \"BS(t=10)\"\n  )) %&gt;%\n  ggplot(aes(x = Measure, y = Value, fill = Measure)) +\n  geom_boxplot(show.legend = FALSE) +\n  geom_jitter(color = \"blue\", size = 0.5, alpha = 0.5, show.legend = FALSE) +\n  labs(title = \"Integrated Brier Score vs Brier Score (t = 10 years)\") +\n  theme_bw(base_size = 14) +\n  theme(axis.title.x = element_blank())\n\n# RCLL\nres[, .(surv.rcll)] %&gt;%\n  tidyr::pivot_longer(\n    cols = tidyselect::everything(),\n    names_to = \"Measure\", values_to = \"Value\"\n  ) %&gt;%\n  mutate(Measure = case_when(\n    Measure == \"surv.rcll\" ~ \"RCLL\"\n  )) %&gt;%\n  ggplot(aes(x = Measure, y = Value)) +\n  geom_boxplot(show.legend = FALSE) +\n  geom_jitter(color = \"blue\", size = 0.5, alpha = 0.5, show.legend = FALSE) +\n  labs(title = \"Right-censored Log Loss\") +\n  theme_bw(base_size = 14) +\n  theme(axis.title.x = element_blank())\n\n\n\n  Calibration performance of Lasso Cox on the TCGA-BRCA dataset (expression data of the PAM50 genes and the variables age and ethnicity). Performance metrics used are the Integrated Brier Score (IBS), the Brier Score at 10 years and the Right-Censored Logarithmic Loss (RCLL). The dataset was split to training/validation sets 100 times to allow for the quantification of uncertainty in the different performance estimates.\n\n\n\nFeature stability analysis\nWe can extract the selected features from all \\(100\\) trained Lasso Cox models and create a frequency selection table:\n\n\nCode\n# get selected features from all trained learners in a list\nsf_list &lt;- lapply(rr$learners, function(learner) {\n  learner$selected_features()\n})\n\n# make frequency selection table\nn &lt;- length(sf_list)\nfs_res &lt;- sort(table(unlist(sf_list)), decreasing = TRUE)\ntimes &lt;- as.vector(unname(fs_res))\ntibble::tibble(feat_name = names(fs_res), times = times, freq = times / n)\n\n\n# A tibble: 35 × 3\n   feat_name times  freq\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt;\n1 age         100  1\n2 ethnicity   100  1\n3 ANLN         43  0.43\n4 BLVRA        41  0.41\n5 BAG1         37  0.37\n6 MIA          34  0.34\n7 TYMS         30  0.3\n8 KRT5         27  0.27\n9 MMP11        27  0.27\n10 BCL2         26  0.26\n# ℹ 25 more rows\nAs age and ethnicity were not penalized, they have non-zero coefficients in all Lasso Cox models and therefore are included in all selected feature sets.\nLastly, we can use the R package stabm (Bommert and Lang 2021) to assess how similar the \\(100\\) selected feature sets were. We will demonstrate the use of three metrics which measure the stability of the Lasso Cox’s feature selection on the TCGA-BRCA dataset:\n\nThe Jaccard index\nNogueira’s metric (corrected for chance, i.e. independent of the number of features; Nogueira, Sechidis, and Brown (2018))\nZucknick’s metric (extension of Jaccard index that considers the correlation between the features; Zucknick, Richardson, and Stronach (2008)):\n\n\n\nCode\nset.seed(42)\njac &lt;- stabm::stabilityJaccard(features = sf_list, correction.for.chance = \"none\")\nnog &lt;- stabm::stabilityNogueira(features = sf_list, p = length(task$feature_names))\n\n# Similarity of each pair of features using Pearson correlation\nsim.mat &lt;- abs(stats::cor(x = task$data(cols = task$feature_names), method = \"p\"))\nzuck &lt;- stabm::stabilityZucknick(\n  features = sf_list, sim.mat = sim.mat,\n  threshold = 0.9, correction.for.chance = \"estimate\", N = 100\n)\n\ntibble::tibble(jaccard = jac, nogueira = nog, zucknick = zuck)\n\n\n# A tibble: 1 × 3\n  jaccard nogueira zucknick\n    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1   0.474    0.412    0.442\nFrom the above values we conclude that the stability of Lasso Cox’s feature selection is neither poor nor excellent but somewhere in between."
  }
]